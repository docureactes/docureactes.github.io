"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[2145],{946:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>r,contentTitle:()=>i,default:()=>l,frontMatter:()=>t,metadata:()=>c,toc:()=>u});var s=n(4848),o=n(8453);const t={},i="useLayoutEffect",c={id:"Hook/7-6-useLayoutEffect",title:"useLayoutEffect",description:"El useLayoutEffect es un hook en React que se parece mucho a useEffect, pero con una diferencia clave en cuanto al momento en que se ejecuta. Mientras que useEffect se ejecuta despu\xe9s de que el renderizado est\xe9 pintado en la pantalla, useLayoutEffect se ejecuta justo despu\xe9s del renderizado, pero antes de que el navegador actualice lo que el usuario ve en la pantalla. Esto significa que useLayoutEffect se ejecuta sincr\xf3nicamente durante el proceso de renderizado, lo que puede ser \xfatil para realizar mediciones o ajustes que deban aplicarse antes de que el navegador pinte la pantalla.",source:"@site/docs/7-Hook/7-6-useLayoutEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-6-useLayoutEffect",permalink:"/Hook/7-6-useLayoutEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useReducer",permalink:"/Hook/7-5-useReducer"},next:{title:"Diferencias entre useLayoutEffect y useEffect",permalink:"/Hook/7-7-Diferencias entre useLayoutEffect y useEffect"}},r={},u=[{value:"\xbfCu\xe1ndo usar <code>useLayoutEffect</code>?",id:"cu\xe1ndo-usar-uselayouteffect",level:2},{value:"Ejemplo b\xe1sico de <code>useLayoutEffect</code>",id:"ejemplo-b\xe1sico-de-uselayouteffect",level:2},{value:"\xbfQu\xe9 hace este c\xf3digo?",id:"qu\xe9-hace-este-c\xf3digo",level:3},{value:"Diferencias clave entre <code>useEffect</code> y <code>useLayoutEffect</code>",id:"diferencias-clave-entre-useeffect-y-uselayouteffect",level:2},{value:"Consideraciones importantes",id:"consideraciones-importantes",level:2},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function d(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.h1,{id:"uselayouteffect",children:"useLayoutEffect"}),"\n",(0,s.jsxs)(a.p,{children:["El ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," es un hook en React que se parece mucho a ",(0,s.jsx)(a.code,{children:"useEffect"}),", pero con una diferencia clave en cuanto al momento en que se ejecuta. Mientras que ",(0,s.jsx)(a.code,{children:"useEffect"})," se ejecuta despu\xe9s de que el renderizado est\xe9 pintado en la pantalla, ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," se ejecuta justo despu\xe9s del renderizado, pero antes de que el navegador actualice lo que el usuario ve en la pantalla. Esto significa que ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," se ejecuta sincr\xf3nicamente durante el proceso de renderizado, lo que puede ser \xfatil para realizar mediciones o ajustes que deban aplicarse antes de que el navegador pinte la pantalla."]}),"\n",(0,s.jsxs)(a.h2,{id:"cu\xe1ndo-usar-uselayouteffect",children:["\xbfCu\xe1ndo usar ",(0,s.jsx)(a.code,{children:"useLayoutEffect"}),"?"]}),"\n",(0,s.jsxs)(a.p,{children:["Es recomendable usar ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," en situaciones donde necesitas realizar cambios DOM que deben estar visibles antes de que el usuario vea el resultado del renderizado. Algunos ejemplos incluyen:"]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Medir elementos en el DOM:"})," Si necesitas medir el tama\xf1o de un elemento en el DOM inmediatamente despu\xe9s de que se haya renderizado, ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," te permitir\xe1 hacerlo antes de que el navegador actualice la pantalla."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Aplicar cambios de estilo que afecten el dise\xf1o del documento:"}),' Si los cambios de estilo que realizas en un componente pueden causar "reflujo" o reposicionamiento de otros elementos, es preferible realizar estos cambios dentro de ',(0,s.jsx)(a.code,{children:"useLayoutEffect"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(a.h2,{id:"ejemplo-b\xe1sico-de-uselayouteffect",children:["Ejemplo b\xe1sico de ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsxs)(a.p,{children:["Aqu\xed tienes un ejemplo b\xe1sico para ilustrar c\xf3mo funciona ",(0,s.jsx)(a.code,{children:"useLayoutEffect"}),":"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-jsx",children:"import React, { useState, useLayoutEffect, useRef } from 'react';\n\nfunction ComponenteConUseLayoutEffect() {\n  // Creamos una referencia para un elemento DOM\n  const divRef = useRef(null);\n\n  // Estado para manejar la altura del div\n  const [altura, setAltura] = useState(0);\n\n  useLayoutEffect(() => {\n    // Medimos la altura del div justo despu\xe9s del renderizado\n    if (divRef.current) {\n      setAltura(divRef.current.getBoundingClientRect().height);\n    }\n  }, [altura]);\n\n  return (\n    <div>\n      <div ref={divRef} style={{ padding: '20px', backgroundColor: 'lightblue' }}>\n        {/* Este div tendr\xe1 un tama\xf1o din\xe1mico */}\n        Contenido del div. La altura es: {altura}px\n      </div>\n    </div>\n  );\n}\n\nexport default ComponenteConUseLayoutEffect;\n"})}),"\n",(0,s.jsx)(a.h3,{id:"qu\xe9-hace-este-c\xf3digo",children:"\xbfQu\xe9 hace este c\xf3digo?"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsxs)(a.strong,{children:["Referencia DOM (",(0,s.jsx)(a.code,{children:"useRef"}),")"]}),": Creamos una referencia (",(0,s.jsx)(a.code,{children:"divRef"}),") para apuntar al div que queremos medir."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsxs)(a.strong,{children:["Estado (",(0,s.jsx)(a.code,{children:"useState"}),")"]}),": Mantenemos la altura del div en un estado."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsxs)(a.strong,{children:["Medici\xf3n en ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})]}),": Utilizamos ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," para medir la altura del div despu\xe9s de que se renderiza, pero antes de que el navegador pinte los cambios en la pantalla. Esto asegura que la altura medida es precisa y que cualquier cambio en el DOM se realizar\xe1 antes de que el usuario vea el resultado."]}),"\n"]}),"\n",(0,s.jsxs)(a.h2,{id:"diferencias-clave-entre-useeffect-y-uselayouteffect",children:["Diferencias clave entre ",(0,s.jsx)(a.code,{children:"useEffect"})," y ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Momento de ejecuci\xf3n"}),": ",(0,s.jsx)(a.code,{children:"useEffect"})," se ejecuta despu\xe9s de que el navegador haya actualizado la pantalla, mientras que ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," se ejecuta antes de la actualizaci\xf3n de la pantalla."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Uso recomendado"}),": ",(0,s.jsx)(a.code,{children:"useEffect"})," es m\xe1s adecuado para operaciones que no afectan directamente el dise\xf1o visual inicial, como la obtenci\xf3n de datos o la configuraci\xf3n de un temporizador. Por otro lado, ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," es ideal para operaciones que deben completarse antes de que el usuario vea el resultado del renderizado."]}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"consideraciones-importantes",children:"Consideraciones importantes"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Rendimiento"}),": Como ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," se ejecuta sincr\xf3nicamente, puede bloquear la pintura de la p\xe1gina si se utiliza de manera ineficiente. Es importante usarlo solo cuando realmente necesites que algo ocurra antes de que el navegador actualice la pantalla."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Efectos secundarios"}),": Si bien ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})," te permite hacer cambios antes de que se presente la interfaz al usuario, abusar de \xe9l puede llevar a una experiencia de usuario menos fluida debido a la potencial p\xe9rdida de rendimiento."]}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:"Hooks en React"}),"\n",(0,s.jsxs)(a.li,{children:["Diferencias entre ",(0,s.jsx)(a.code,{children:"useEffect"})," y ",(0,s.jsx)(a.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsx)(a.li,{children:"Medici\xf3n y manipulaci\xf3n del DOM en React"}),"\n",(0,s.jsx)(a.li,{children:"Optimizaci\xf3n del rendimiento en React"}),"\n"]}),"\n",(0,s.jsx)(a.h2,{id:"resumen",children:"Resumen"}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.code,{children:"useLayoutEffect"})," es un hook poderoso en React que se ejecuta justo despu\xe9s del renderizado pero antes de que el navegador actualice la pantalla. Es \xfatil para tareas que necesitan realizarse antes de que el usuario vea los cambios en la UI, como mediciones del DOM y ajustes de estilo que afectan el dise\xf1o. Sin embargo, debido a su ejecuci\xf3n sincr\xf3nica, debe usarse con precauci\xf3n para evitar problemas de rendimiento."]})]})}function l(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>c});var s=n(6540);const o={},t=s.createContext(o);function i(e){const a=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function c(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(t.Provider,{value:a},e.children)}}}]);