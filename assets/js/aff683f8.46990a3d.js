"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[9739],{4544:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var a=s(4848),o=s(8453);const r={},c="Gesti\xf3n de operaciones as\xedncronas dentro de useEffect",i={id:"Ciclo de vida/4-4-Gesti\xf3n de operaciones as\xedncronas dentro de useEffect",title:"Gesti\xf3n de operaciones as\xedncronas dentro de useEffect",description:"En React, el hook useEffect es una herramienta fundamental para manejar efectos secundarios en los componentes, como la suscripci\xf3n a servicios, la limpieza de recursos o, en nuestro caso, la gesti\xf3n de operaciones as\xedncronas. Es importante entender c\xf3mo y cu\xe1ndo ejecutar estas operaciones de manera eficiente y segura para mantener el rendimiento y la estabilidad de nuestras aplicaciones.",source:"@site/docs/4-Ciclo de vida/4-4-Gesti\xf3n de operaciones as\xedncronas dentro de useEffect.md",sourceDirName:"4-Ciclo de vida",slug:"/Ciclo de vida/4-4-Gesti\xf3n de operaciones as\xedncronas dentro de useEffect",permalink:"/Ciclo de vida/4-4-Gesti\xf3n de operaciones as\xedncronas dentro de useEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Razones para que useEffect realice una sola tarea",permalink:"/Ciclo de vida/4-3-Razones para que useEffect realice una sola tarea"},next:{title:"Introducci\xf3n a componentes y buenos nombres para componentes",permalink:"/Componente/5-1-Introducci\xf3n a componentes y buenos nombres para componentes"}},t={},d=[{value:"\xbfPor qu\xe9 usar operaciones as\xedncronas dentro de useEffect?",id:"por-qu\xe9-usar-operaciones-as\xedncronas-dentro-de-useeffect",level:2},{value:"Ejemplo b\xe1sico de operaci\xf3n as\xedncrona en useEffect",id:"ejemplo-b\xe1sico-de-operaci\xf3n-as\xedncrona-en-useeffect",level:3},{value:"Conceptos clave a tener en cuenta",id:"conceptos-clave-a-tener-en-cuenta",level:3},{value:"Limpieza de efectos as\xedncronos",id:"limpieza-de-efectos-as\xedncronos",level:2},{value:"Puntos importantes:",id:"puntos-importantes",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"gesti\xf3n-de-operaciones-as\xedncronas-dentro-de-useeffect",children:"Gesti\xf3n de operaciones as\xedncronas dentro de useEffect"}),"\n",(0,a.jsxs)(n.p,{children:["En React, el hook ",(0,a.jsx)(n.code,{children:"useEffect"})," es una herramienta fundamental para manejar efectos secundarios en los componentes, como la suscripci\xf3n a servicios, la limpieza de recursos o, en nuestro caso, la gesti\xf3n de operaciones as\xedncronas. Es importante entender c\xf3mo y cu\xe1ndo ejecutar estas operaciones de manera eficiente y segura para mantener el rendimiento y la estabilidad de nuestras aplicaciones."]}),"\n",(0,a.jsx)(n.h2,{id:"por-qu\xe9-usar-operaciones-as\xedncronas-dentro-de-useeffect",children:"\xbfPor qu\xe9 usar operaciones as\xedncronas dentro de useEffect?"}),"\n",(0,a.jsxs)(n.p,{children:["Las operaciones as\xedncronas, como llamadas a APIs o funciones que devuelven promesas, son comunes en las aplicaciones modernas. ",(0,a.jsx)(n.code,{children:"useEffect"})," es el lugar id\xf3neo para manejarlas porque permite ejecutar c\xf3digo despu\xe9s de que el componente se haya renderizado. De esta manera, puedes asegurarte de que la aplicaci\xf3n est\xe9 en el estado correcto antes de intentar realizar la operaci\xf3n."]}),"\n",(0,a.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-operaci\xf3n-as\xedncrona-en-useeffect",children:"Ejemplo b\xe1sico de operaci\xf3n as\xedncrona en useEffect"}),"\n",(0,a.jsx)(n.p,{children:"Veamos un ejemplo simple donde realizamos una llamada a una API para obtener datos de usuarios:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useEffect } from 'react';\n\nfunction ListaDeUsuarios() {\n  // Definimos un estado para almacenar los datos de los usuarios\n  const [usuarios, setUsuarios] = useState([]);\n  \n  // useEffect que maneja la operaci\xf3n as\xedncrona\n  useEffect(() => {\n    // Definimos una funci\xf3n as\xedncrona dentro de useEffect\n    const obtenerUsuarios = async () => {\n      try {\n        // Hacemos la llamada a la API\n        const respuesta = await fetch('https://jsonplaceholder.typicode.com/users');\n        const datos = await respuesta.json();\n        // Actualizamos el estado con los datos obtenidos\n        setUsuarios(datos);\n      } catch (error) {\n        console.error('Error al obtener los usuarios:', error);\n      }\n    };\n\n    // Llamamos a la funci\xf3n as\xedncrona\n    obtenerUsuarios();\n  }, []); // [] indica que el efecto se ejecuta una sola vez, como componentDidMount\n\n  return (\n    <div>\n      <h2>Lista de Usuarios</h2>\n      <ul>\n        {/* Renderizamos la lista de usuarios */}\n        {usuarios.map((usuario) => (\n          <li key={usuario.id}>{usuario.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport default ListaDeUsuarios;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"conceptos-clave-a-tener-en-cuenta",children:"Conceptos clave a tener en cuenta"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Definir funciones as\xedncronas dentro de useEffect"}),": Es importante definir la funci\xf3n as\xedncrona dentro de ",(0,a.jsx)(n.code,{children:"useEffect"})," para que no haya efectos secundarios inesperados. Aunque podr\xedas definir la funci\xf3n fuera, esto podr\xeda llevar a problemas con la gesti\xf3n del estado si ",(0,a.jsx)(n.code,{children:"useEffect"})," se ejecuta varias veces."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Uso de un array de dependencias vac\xedo (",(0,a.jsx)(n.code,{children:"[]"}),")"]}),": Al pasar un array vac\xedo como segundo argumento de ",(0,a.jsx)(n.code,{children:"useEffect"}),", aseguramos que el efecto se ejecute solo una vez, imitando el comportamiento de ",(0,a.jsx)(n.code,{children:"componentDidMount"})," en componentes de clase."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Manejo de errores"}),": Es crucial manejar cualquier posible error que pueda ocurrir durante la operaci\xf3n as\xedncrona para evitar que la aplicaci\xf3n falle sin un mensaje claro."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"limpieza-de-efectos-as\xedncronos",children:"Limpieza de efectos as\xedncronos"}),"\n",(0,a.jsxs)(n.p,{children:["A veces, es necesario cancelar una operaci\xf3n as\xedncrona si el componente se desmonta antes de que esta termine. Podemos manejar esto usando la limpieza en ",(0,a.jsx)(n.code,{children:"useEffect"}),". Aqu\xed te mostramos c\xf3mo hacerlo:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n  let cancelado = false;\n\n  const obtenerUsuarios = async () => {\n    try {\n      const respuesta = await fetch('https://jsonplaceholder.typicode.com/users');\n      const datos = await respuesta.json();\n      if (!cancelado) {\n        setUsuarios(datos);\n      }\n    } catch (error) {\n      if (!cancelado) {\n        console.error('Error al obtener los usuarios:', error);\n      }\n    }\n  };\n\n  obtenerUsuarios();\n\n  // Funci\xf3n de limpieza para cancelar la operaci\xf3n si el componente se desmonta\n  return () => {\n    cancelado = true;\n  };\n}, []);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"puntos-importantes",children:"Puntos importantes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Uso de una bandera de cancelaci\xf3n (",(0,a.jsx)(n.code,{children:"cancelado"}),")"]}),": Este patr\xf3n nos permite evitar actualizaciones de estado en componentes desmontados, lo cual puede generar errores en la aplicaci\xf3n."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Funci\xf3n de limpieza (",(0,a.jsx)(n.code,{children:"return () => {}"}),")"]}),": ",(0,a.jsx)(n.code,{children:"useEffect"})," puede retornar una funci\xf3n que se ejecutar\xe1 cuando el componente se desmonte, lo que es \xfatil para limpiar recursos o cancelar operaciones."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useEffect"})}),": Una comprensi\xf3n m\xe1s profunda de c\xf3mo funciona este hook."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Operaciones as\xedncronas en JavaScript"}),": Promesas, ",(0,a.jsx)(n.code,{children:"async"})," y ",(0,a.jsx)(n.code,{children:"await"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Manejo de errores"}),": C\xf3mo gestionar adecuadamente los errores en c\xf3digo as\xedncrono."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Optimizaci\xf3n de rendimiento"}),": C\xf3mo evitar renderizados innecesarios en React."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,a.jsxs)(n.p,{children:["El manejo de operaciones as\xedncronas dentro de ",(0,a.jsx)(n.code,{children:"useEffect"})," es esencial para realizar tareas como la obtenci\xf3n de datos de una API en React. Es importante definir las funciones as\xedncronas dentro de ",(0,a.jsx)(n.code,{children:"useEffect"}),", manejar los errores correctamente y considerar la limpieza de efectos para evitar actualizaciones en componentes desmontados. Con estas t\xe9cnicas, puedes asegurarte de que tu aplicaci\xf3n sea m\xe1s robusta y est\xe9 libre de errores comunes."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>i});var a=s(6540);const o={},r=a.createContext(o);function c(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:c(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);