"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[2246],{9735:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=n(4848),t=n(8453);const r={},i="Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",s={id:"State/2-8-Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",title:"Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",description:"Cuando trabajamos con state en React, es fundamental comprender que la funci\xf3n que actualiza el estado (setState en los componentes de clase o la funci\xf3n retornada por useState en los componentes funcionales) es as\xedncrona. Esto significa que las actualizaciones del estado no se aplican de inmediato, sino que React las agrupa y las procesa en lotes para optimizar el rendimiento.",source:"@site/docs/2-State/2-8-Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado.md",sourceDirName:"2-State",slug:"/State/2-8-Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",permalink:"/State/2-8-Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",permalink:"/State/2-7-Introducci\xf3n a useRef y uso de variables de componente en lugar de useState"},next:{title:"Introducci\xf3n a Props y buenos nombres para Props",permalink:"/Props/3-1-Introducci\xf3n a Props y buenos nombres para Props"}},c={},l=[{value:"La naturaleza as\xedncrona de <code>setState</code>",id:"la-naturaleza-as\xedncrona-de-setstate",level:3},{value:"Aprovechamiento del estado anterior",id:"aprovechamiento-del-estado-anterior",level:3},{value:"Reinicializaci\xf3n del estado",id:"reinicializaci\xf3n-del-estado",level:3},{value:"Puntos clave a tener en cuenta",id:"puntos-clave-a-tener-en-cuenta",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function d(e){const a={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.h1,{id:"naturaleza-as\xedncrona-de-la-funci\xf3n-de-actualizaci\xf3n-del-estado-aprovechamiento-del-estado-anterior-y-reinicializaci\xf3n-del-estado",children:"Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado"}),"\n",(0,o.jsxs)(a.p,{children:["Cuando trabajamos con ",(0,o.jsx)(a.strong,{children:"state"})," en React, es fundamental comprender que la funci\xf3n que actualiza el estado (",(0,o.jsx)(a.code,{children:"setState"})," en los componentes de clase o la funci\xf3n retornada por ",(0,o.jsx)(a.code,{children:"useState"})," en los componentes funcionales) es as\xedncrona. Esto significa que las actualizaciones del estado no se aplican de inmediato, sino que React las agrupa y las procesa en lotes para optimizar el rendimiento."]}),"\n",(0,o.jsxs)(a.h3,{id:"la-naturaleza-as\xedncrona-de-setstate",children:["La naturaleza as\xedncrona de ",(0,o.jsx)(a.code,{children:"setState"})]}),"\n",(0,o.jsxs)(a.p,{children:["El hecho de que ",(0,o.jsx)(a.code,{children:"setState"})," sea as\xedncrono puede llevar a comportamientos inesperados si no se maneja adecuadamente. Un error com\xfan es intentar leer el valor actualizado del estado inmediatamente despu\xe9s de llamarlo, como en el siguiente ejemplo:"]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nfunction Contador() {\n  const [contador, setContador] = useState(0);\n\n  const incrementarContador = () => {\n    setContador(contador + 1);\n    console.log(contador); // Aqu\xed podr\xeda imprimir un valor desactualizado\n  };\n\n  return (\n    <div>\n      <p>Contador: {contador}</p>\n      <button onClick={incrementarContador}>Incrementar</button>\n    </div>\n  );\n}\n\nexport default Contador;\n"})}),"\n",(0,o.jsxs)(a.p,{children:["En el ejemplo anterior, aunque ",(0,o.jsx)(a.code,{children:"setContador(contador + 1)"})," se ejecuta, es posible que el ",(0,o.jsx)(a.code,{children:"console.log(contador)"})," no muestre el valor actualizado de ",(0,o.jsx)(a.code,{children:"contador"})," debido a la naturaleza as\xedncrona de ",(0,o.jsx)(a.code,{children:"setState"}),"."]}),"\n",(0,o.jsx)(a.h3,{id:"aprovechamiento-del-estado-anterior",children:"Aprovechamiento del estado anterior"}),"\n",(0,o.jsxs)(a.p,{children:["Para evitar problemas con la actualizaci\xf3n as\xedncrona, puedes aprovechar el estado anterior usando la funci\xf3n de actualizaci\xf3n que recibe ",(0,o.jsx)(a.code,{children:"setState"})," o la funci\xf3n de actualizaci\xf3n de ",(0,o.jsx)(a.code,{children:"useState"}),". De esta manera, React garantiza que siempre est\xe9s trabajando con el valor m\xe1s reciente del estado:"]}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nfunction Contador() {\n  const [contador, setContador] = useState(0);\n\n  const incrementarContador = () => {\n    setContador(prevContador => prevContador + 1); // Usamos el estado anterior\n    console.log(contador); // Aqu\xed el valor podr\xeda no estar actualizado\n  };\n\n  return (\n    <div>\n      <p>Contador: {contador}</p>\n      <button onClick={incrementarContador}>Incrementar</button>\n    </div>\n  );\n}\n\nexport default Contador;\n"})}),"\n",(0,o.jsxs)(a.p,{children:["En este ejemplo, ",(0,o.jsx)(a.code,{children:"setContador(prevContador => prevContador + 1)"})," asegura que el estado anterior, ",(0,o.jsx)(a.code,{children:"prevContador"}),", se use para calcular el nuevo estado, evitando posibles errores cuando el estado depende de su valor anterior."]}),"\n",(0,o.jsx)(a.h3,{id:"reinicializaci\xf3n-del-estado",children:"Reinicializaci\xf3n del estado"}),"\n",(0,o.jsx)(a.p,{children:'En algunos casos, es posible que necesites reiniciar el estado a su valor inicial. Esto es \xfatil cuando un componente necesita "empezar de nuevo" bajo ciertas condiciones. Aqu\xed te mostramos c\xf3mo hacerlo:'}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-javascript",children:'import React, { useState } from \'react\';\n\nfunction Formulario() {\n  const valorInicial = { nombre: \'\', correo: \'\' };\n  const [datos, setDatos] = useState(valorInicial);\n\n  const manejarCambio = e => {\n    const { name, value } = e.target;\n    setDatos(prevDatos => ({ ...prevDatos, [name]: value }));\n  };\n\n  const reiniciarFormulario = () => {\n    setDatos(valorInicial); // Reinicializamos el estado\n  };\n\n  return (\n    <div>\n      <input\n        type="text"\n        name="nombre"\n        value={datos.nombre}\n        onChange={manejarCambio}\n        placeholder="Nombre"\n      />\n      <input\n        type="email"\n        name="correo"\n        value={datos.correo}\n        onChange={manejarCambio}\n        placeholder="Correo"\n      />\n      <button onClick={reiniciarFormulario}>Reiniciar</button>\n    </div>\n  );\n}\n\nexport default Formulario;\n'})}),"\n",(0,o.jsx)(a.p,{children:'En este caso, al hacer clic en el bot\xf3n de "Reiniciar", el formulario vuelve a su estado inicial, lo cual es \xfatil cuando necesitas limpiar el formulario despu\xe9s de enviarlo.'}),"\n",(0,o.jsx)(a.h3,{id:"puntos-clave-a-tener-en-cuenta",children:"Puntos clave a tener en cuenta"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsxs)(a.li,{children:[(0,o.jsxs)(a.strong,{children:["Asincron\xeda de ",(0,o.jsx)(a.code,{children:"setState"})]}),": No conf\xedes en el estado actualizado inmediatamente despu\xe9s de llamarlo."]}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Uso de funciones de actualizaci\xf3n"}),": Aprovecha las funciones de actualizaci\xf3n (",(0,o.jsx)(a.code,{children:"prevState"}),") para garantizar que trabajas con el valor m\xe1s reciente del estado."]}),"\n",(0,o.jsxs)(a.li,{children:[(0,o.jsx)(a.strong,{children:"Reinicializaci\xf3n del estado"}),": Usa el estado inicial almacenado en una variable o constante para reiniciarlo cuando sea necesario."]}),"\n"]}),"\n",(0,o.jsx)(a.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,o.jsxs)(a.ul,{children:["\n",(0,o.jsx)(a.li,{children:(0,o.jsx)(a.strong,{children:"Asincron\xeda en React"})}),"\n",(0,o.jsx)(a.li,{children:(0,o.jsx)(a.strong,{children:"Gesti\xf3n de estado en componentes funcionales"})}),"\n",(0,o.jsx)(a.li,{children:(0,o.jsx)(a.strong,{children:"Buenas pr\xe1cticas con useState"})}),"\n"]}),"\n",(0,o.jsx)(a.h2,{id:"resumen",children:"Resumen"}),"\n",(0,o.jsx)(a.p,{children:"La actualizaci\xf3n del estado en React es as\xedncrona, lo que significa que no se reflejar\xe1 inmediatamente. Para trabajar correctamente con el estado, es recomendable utilizar funciones de actualizaci\xf3n que reciban el estado anterior, especialmente cuando el nuevo estado depende de su valor anterior. Adem\xe1s, la reinicializaci\xf3n del estado es una t\xe9cnica \xfatil cuando necesitas restablecer componentes a su estado inicial."})]})}function u(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>s});var o=n(6540);const t={},r=o.createContext(t);function i(e){const a=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(r.Provider,{value:a},e.children)}}}]);