"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[4573],{1118:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>t,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var a=s(4848),o=s(8453);const r={},t="Puntos a tener en cuenta al trabajar con atributos HTML",c={id:"Props/3-8-Puntos a tener en cuenta al trabajar con atributos HTML",title:"Puntos a tener en cuenta al trabajar con atributos HTML",description:"Cuando trabajamos con React, es importante recordar que los atributos HTML en JSX (la sintaxis que se usa para escribir componentes en React) tienen algunas peculiaridades. A continuaci\xf3n, repasaremos los aspectos m\xe1s importantes que debes tener en cuenta al manejar estos atributos para que tus componentes funcionen correctamente y tu c\xf3digo sea m\xe1s limpio y mantenible.",source:"@site/docs/3-Props/3-8-Puntos a tener en cuenta al trabajar con atributos HTML.md",sourceDirName:"3-Props",slug:"/Props/3-8-Puntos a tener en cuenta al trabajar con atributos HTML",permalink:"/Props/3-8-Puntos a tener en cuenta al trabajar con atributos HTML",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Razones para dividir Props complejos y ventajas de Props simples",permalink:"/Props/3-7-Razones para dividir Props complejos y ventajas de Props simples"},next:{title:"defaultProps",permalink:"/Props/3-9-defaultProps"}},i={},l=[{value:"1. <strong>Atributos camelCase</strong>",id:"1-atributos-camelcase",level:2},{value:"2. <strong>Atributos booleanos</strong>",id:"2-atributos-booleanos",level:2},{value:"3. <strong>Atributos que esperan funciones</strong>",id:"3-atributos-que-esperan-funciones",level:2},{value:"4. <strong>Atributos personalizados y <code>data-*</code></strong>",id:"4-atributos-personalizados-y-data-",level:2},{value:"5. <strong>Atributos de estilo</strong>",id:"5-atributos-de-estilo",level:2},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"puntos-a-tener-en-cuenta-al-trabajar-con-atributos-html",children:"Puntos a tener en cuenta al trabajar con atributos HTML"}),"\n",(0,a.jsx)(n.p,{children:"Cuando trabajamos con React, es importante recordar que los atributos HTML en JSX (la sintaxis que se usa para escribir componentes en React) tienen algunas peculiaridades. A continuaci\xf3n, repasaremos los aspectos m\xe1s importantes que debes tener en cuenta al manejar estos atributos para que tus componentes funcionen correctamente y tu c\xf3digo sea m\xe1s limpio y mantenible."}),"\n",(0,a.jsxs)(n.h2,{id:"1-atributos-camelcase",children:["1. ",(0,a.jsx)(n.strong,{children:"Atributos camelCase"})]}),"\n",(0,a.jsxs)(n.p,{children:["En HTML tradicional, los atributos suelen escribirse en min\xfasculas. Sin embargo, en JSX, la convenci\xf3n es escribirlos en ",(0,a.jsx)(n.code,{children:"camelCase"}),". Esto significa que, en lugar de ",(0,a.jsx)(n.code,{children:"class"}),", usaremos ",(0,a.jsx)(n.code,{children:"className"}),", y en lugar de ",(0,a.jsx)(n.code,{children:"onclick"}),", usaremos ",(0,a.jsx)(n.code,{children:"onClick"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Ejemplo incorrecto\n<button class="mi-boton" onclick="handleClick()">Haz clic</button>\n\n// Ejemplo correcto en JSX\n<button className="mi-boton" onClick={handleClick}>Haz clic</button>\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xa1Punto clave!"}),": Aseg\xfarate de cambiar todos los atributos HTML tradicionales a su equivalente en ",(0,a.jsx)(n.code,{children:"camelCase"})," cuando trabajes en JSX para evitar errores."]}),"\n",(0,a.jsxs)(n.h2,{id:"2-atributos-booleanos",children:["2. ",(0,a.jsx)(n.strong,{children:"Atributos booleanos"})]}),"\n",(0,a.jsxs)(n.p,{children:["En HTML tradicional, los atributos booleanos (como ",(0,a.jsx)(n.code,{children:"disabled"})," o ",(0,a.jsx)(n.code,{children:"checked"}),") se pueden escribir solos. En JSX, sin embargo, debes asignarles un valor, generalmente ",(0,a.jsx)(n.code,{children:"true"})," o ",(0,a.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// HTML tradicional\n<input type="checkbox" checked>\n\n// JSX correcto\n<input type="checkbox" checked={true} />\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Si quieres que el atributo no est\xe9 presente, simplemente asigna ",(0,a.jsx)(n.code,{children:"false"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'<input type="checkbox" checked={false} />\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xa1Punto clave!"}),": En JSX, siempre asigna un valor a los atributos booleanos para garantizar que se comporten como esperas."]}),"\n",(0,a.jsxs)(n.h2,{id:"3-atributos-que-esperan-funciones",children:["3. ",(0,a.jsx)(n.strong,{children:"Atributos que esperan funciones"})]}),"\n",(0,a.jsxs)(n.p,{children:["Algunos atributos, como ",(0,a.jsx)(n.code,{children:"onClick"}),", ",(0,a.jsx)(n.code,{children:"onChange"}),", etc., esperan una funci\xf3n en lugar de una cadena de texto. En React, es crucial pasar una referencia a la funci\xf3n, no su ejecuci\xf3n directa."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Ejemplo incorrecto\n<button onClick={handleClick()}>Haz clic</button>\n\n// Ejemplo correcto\n<button onClick={handleClick}>Haz clic</button>\n"})}),"\n",(0,a.jsxs)(n.p,{children:["En el ejemplo incorrecto, la funci\xf3n ",(0,a.jsx)(n.code,{children:"handleClick"})," se ejecuta inmediatamente en lugar de ser pasada como referencia, lo que suele causar problemas."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xa1Punto clave!"}),": Cuando asignes funciones a atributos de evento, pasa la referencia a la funci\xf3n, no la ejecutes directamente."]}),"\n",(0,a.jsxs)(n.h2,{id:"4-atributos-personalizados-y-data-",children:["4. ",(0,a.jsxs)(n.strong,{children:["Atributos personalizados y ",(0,a.jsx)(n.code,{children:"data-*"})]})]}),"\n",(0,a.jsxs)(n.p,{children:["React permite usar atributos personalizados mediante el prefijo ",(0,a.jsx)(n.code,{children:"data-"}),". Estos atributos son \xfatiles para almacenar informaci\xf3n adicional en los elementos HTML."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'// Ejemplo de atributo personalizado\n<div data-id="123" data-role="admin">Contenido</div>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Estos atributos se pueden acceder en JavaScript utilizando ",(0,a.jsx)(n.code,{children:"dataset"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-javascript",children:'const elemento = document.querySelector(\'div\');\nconsole.log(elemento.dataset.id); // "123"\nconsole.log(elemento.dataset.role); // "admin"\n'})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xa1Punto clave!"}),": Utiliza ",(0,a.jsx)(n.code,{children:"data-*"})," para atributos personalizados y accede a ellos a trav\xe9s de ",(0,a.jsx)(n.code,{children:"dataset"})," en JavaScript."]}),"\n",(0,a.jsxs)(n.h2,{id:"5-atributos-de-estilo",children:["5. ",(0,a.jsx)(n.strong,{children:"Atributos de estilo"})]}),"\n",(0,a.jsxs)(n.p,{children:["En JSX, el atributo ",(0,a.jsx)(n.code,{children:"style"})," se maneja de forma diferente a como lo har\xedas en HTML. En lugar de una cadena de texto, se espera un objeto con las propiedades CSS en formato ",(0,a.jsx)(n.code,{children:"camelCase"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"// Ejemplo incorrecto en JSX\n<div style=\"background-color: red; color: white;\">Texto</div>\n\n// Ejemplo correcto en JSX\n<div style={{ backgroundColor: 'red', color: 'white' }}>Texto</div>\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xa1Punto clave!"}),": En JSX, usa un objeto para definir estilos en l\xednea y emplea ",(0,a.jsx)(n.code,{children:"camelCase"})," para las propiedades CSS."]}),"\n",(0,a.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"camelCase en JSX"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Atributos booleanos en React"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Eventos en React"})}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsxs)(n.em,{children:[(0,a.jsx)(n.em,{children:"data-"})," en HTML"]}),"*"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Estilos en l\xednea con React"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,a.jsxs)(n.p,{children:["Trabajar con atributos HTML en JSX requiere adaptaciones como el uso de ",(0,a.jsx)(n.code,{children:"camelCase"})," para los nombres de atributos, la asignaci\xf3n expl\xedcita de valores a los booleanos, y el manejo correcto de funciones en los eventos. Adem\xe1s, al definir estilos en l\xednea, es esencial usar un objeto con propiedades en ",(0,a.jsx)(n.code,{children:"camelCase"}),". Estos puntos son fundamentales para asegurar un c\xf3digo React m\xe1s eficiente y sin errores."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var a=s(6540);const o={},r=a.createContext(o);function t(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);