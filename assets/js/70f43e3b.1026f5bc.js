"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[1143],{1158:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>d,toc:()=>l});var a=o(4848),s=o(8453);const i={},c="T\xe9cnicas de optimizaci\xf3n del renderizado",d={id:"Optimizaci\xf3n/8-2-T\xe9cnicas de optimizaci\xf3n del renderizado",title:"T\xe9cnicas de optimizaci\xf3n del renderizado",description:"Cuando trabajamos con React, uno de los objetivos m\xe1s importantes es mantener nuestra aplicaci\xf3n r\xe1pida y eficiente. Esto es crucial porque las aplicaciones de React suelen manejar grandes cantidades de datos y componentes, lo que puede llevar a problemas de rendimiento si no se maneja correctamente. En esta secci\xf3n, exploraremos algunas t\xe9cnicas para optimizar el renderizado en React, asegur\xe1ndonos de que nuestra aplicaci\xf3n sea lo m\xe1s \xe1gil posible.",source:"@site/docs/8-Optimizaci\xf3n/8-2-T\xe9cnicas de optimizaci\xf3n del renderizado.md",sourceDirName:"8-Optimizaci\xf3n",slug:"/Optimizaci\xf3n/8-2-T\xe9cnicas de optimizaci\xf3n del renderizado",permalink:"/Optimizaci\xf3n/8-2-T\xe9cnicas de optimizaci\xf3n del renderizado",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",permalink:"/Optimizaci\xf3n/8-1-T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes"},next:{title:"Estilo en l\xednea",permalink:"/Estilo/9-1-Estilo en l\xednea"}},r={},l=[{value:"\xbfQu\xe9 es el renderizado en React?",id:"qu\xe9-es-el-renderizado-en-react",level:2},{value:"1. Uso de <code>React.memo</code>",id:"1-uso-de-reactmemo",level:2},{value:"Ejemplo b\xe1sico de <code>React.memo</code>",id:"ejemplo-b\xe1sico-de-reactmemo",level:3},{value:"Puntos a tener en cuenta",id:"puntos-a-tener-en-cuenta",level:3},{value:"2. Evitar renderizados innecesarios con <code>shouldComponentUpdate</code>",id:"2-evitar-renderizados-innecesarios-con-shouldcomponentupdate",level:2},{value:"Ejemplo b\xe1sico de <code>shouldComponentUpdate</code>",id:"ejemplo-b\xe1sico-de-shouldcomponentupdate",level:3},{value:"3. Uso de <code>useMemo</code> y <code>useCallback</code>",id:"3-uso-de-usememo-y-usecallback",level:2},{value:"Ejemplo b\xe1sico de <code>useMemo</code> y <code>useCallback</code>",id:"ejemplo-b\xe1sico-de-usememo-y-usecallback",level:3},{value:"4. Carga diferida de componentes (Lazy Loading)",id:"4-carga-diferida-de-componentes-lazy-loading",level:2},{value:"Ejemplo b\xe1sico de carga diferida",id:"ejemplo-b\xe1sico-de-carga-diferida",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function t(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"t\xe9cnicas-de-optimizaci\xf3n-del-renderizado",children:"T\xe9cnicas de optimizaci\xf3n del renderizado"}),"\n",(0,a.jsx)(n.p,{children:"Cuando trabajamos con React, uno de los objetivos m\xe1s importantes es mantener nuestra aplicaci\xf3n r\xe1pida y eficiente. Esto es crucial porque las aplicaciones de React suelen manejar grandes cantidades de datos y componentes, lo que puede llevar a problemas de rendimiento si no se maneja correctamente. En esta secci\xf3n, exploraremos algunas t\xe9cnicas para optimizar el renderizado en React, asegur\xe1ndonos de que nuestra aplicaci\xf3n sea lo m\xe1s \xe1gil posible."}),"\n",(0,a.jsx)(n.h2,{id:"qu\xe9-es-el-renderizado-en-react",children:"\xbfQu\xe9 es el renderizado en React?"}),"\n",(0,a.jsxs)(n.p,{children:["El renderizado en React se refiere al proceso en el que React actualiza el DOM para reflejar los cambios en la interfaz de usuario. Cada vez que cambia el estado (",(0,a.jsx)(n.code,{children:"state"}),") o las propiedades (",(0,a.jsx)(n.code,{children:"props"}),") de un componente, React decide si necesita actualizar la interfaz de usuario. Si no optimizamos este proceso, nuestra aplicaci\xf3n puede realizar m\xe1s actualizaciones de las necesarias, lo que afecta el rendimiento."]}),"\n",(0,a.jsxs)(n.h2,{id:"1-uso-de-reactmemo",children:["1. Uso de ",(0,a.jsx)(n.code,{children:"React.memo"})]}),"\n",(0,a.jsxs)(n.p,{children:["Una de las formas m\xe1s simples y efectivas de optimizar el renderizado es utilizando ",(0,a.jsx)(n.code,{children:"React.memo"}),". Este es un componente de orden superior que memoriza los resultados de un componente funcional. En otras palabras, si las propiedades (",(0,a.jsx)(n.code,{children:"props"}),") de un componente no han cambiado, ",(0,a.jsx)(n.code,{children:"React.memo"})," puede evitar que el componente se vuelva a renderizar."]}),"\n",(0,a.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-reactmemo",children:["Ejemplo b\xe1sico de ",(0,a.jsx)(n.code,{children:"React.memo"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\n\n// Componente funcional simple\nconst MiComponente = ({ mensaje }) => {\n  console.log('Renderizando MiComponente');\n  return <div>{mensaje}</div>;\n};\n\n// Usamos React.memo para evitar renderizados innecesarios\nconst MiComponenteMemo = React.memo(MiComponente);\n\nconst App = () => {\n  const [contador, setContador] = React.useState(0);\n\n  return (\n    <div>\n      <MiComponenteMemo mensaje=\"Hola, mundo!\" />\n      <button onClick={() => setContador(contador + 1)}>\n        Incrementar contador\n      </button>\n      <p>Contador: {contador}</p>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xbfQu\xe9 sucede aqu\xed?"}),(0,a.jsx)(n.br,{}),"\n","En este ejemplo, ",(0,a.jsx)(n.code,{children:"MiComponente"})," solo se renderizar\xe1 la primera vez, ya que su propiedad ",(0,a.jsx)(n.code,{children:"mensaje"})," no cambia. Cada vez que hacemos clic en el bot\xf3n, se incrementa el ",(0,a.jsx)(n.code,{children:"contador"}),", pero ",(0,a.jsx)(n.code,{children:"MiComponenteMemo"})," no se vuelve a renderizar porque sus ",(0,a.jsx)(n.code,{children:"props"})," permanecen iguales."]}),"\n",(0,a.jsx)(n.h3,{id:"puntos-a-tener-en-cuenta",children:"Puntos a tener en cuenta"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"React.memo"})," es m\xe1s efectivo para componentes funcionales que reciben un n\xfamero limitado de propiedades."]}),"\n",(0,a.jsxs)(n.li,{children:["Si el componente tiene una l\xf3gica compleja de renderizado o recibe muchas ",(0,a.jsx)(n.code,{children:"props"}),", puede que ",(0,a.jsx)(n.code,{children:"React.memo"})," no sea suficiente y se deban explorar otras t\xe9cnicas."]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"2-evitar-renderizados-innecesarios-con-shouldcomponentupdate",children:["2. Evitar renderizados innecesarios con ",(0,a.jsx)(n.code,{children:"shouldComponentUpdate"})]}),"\n",(0,a.jsxs)(n.p,{children:["Para componentes de clase, se puede utilizar el m\xe9todo ",(0,a.jsx)(n.code,{children:"shouldComponentUpdate"}),", que le dice a React si debe o no volver a renderizar el componente cuando cambian las ",(0,a.jsx)(n.code,{children:"props"})," o el ",(0,a.jsx)(n.code,{children:"state"}),"."]}),"\n",(0,a.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-shouldcomponentupdate",children:["Ejemplo b\xe1sico de ",(0,a.jsx)(n.code,{children:"shouldComponentUpdate"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React, { Component } from 'react';\n\nclass MiComponenteClase extends Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    // Solo vuelve a renderizar si la propiedad 'mensaje' cambia\n    return nextProps.mensaje !== this.props.mensaje;\n  }\n\n  render() {\n    console.log('Renderizando MiComponenteClase');\n    return <div>{this.props.mensaje}</div>;\n  }\n}\n\nexport default MiComponenteClase;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xbfQu\xe9 sucede aqu\xed?"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.code,{children:"MiComponenteClase"})," solo se renderizar\xe1 si la propiedad ",(0,a.jsx)(n.code,{children:"mensaje"})," cambia. Esto evita renderizados innecesarios y optimiza el rendimiento."]}),"\n",(0,a.jsxs)(n.h2,{id:"3-uso-de-usememo-y-usecallback",children:["3. Uso de ",(0,a.jsx)(n.code,{children:"useMemo"})," y ",(0,a.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,a.jsxs)(n.p,{children:["Otra t\xe9cnica importante es el uso de los hooks ",(0,a.jsx)(n.code,{children:"useMemo"})," y ",(0,a.jsx)(n.code,{children:"useCallback"}),". Ambos son \xfatiles para memorizar valores y funciones, respectivamente, evitando c\xe1lculos costosos o recreaciones de funciones en cada renderizado."]}),"\n",(0,a.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-usememo-y-usecallback",children:["Ejemplo b\xe1sico de ",(0,a.jsx)(n.code,{children:"useMemo"})," y ",(0,a.jsx)(n.code,{children:"useCallback"})]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React, { useState, useMemo, useCallback } from 'react';\n\nconst App = () => {\n  const [contador, setContador] = useState(0);\n\n  const calculoCostoso = useMemo(() => {\n    console.log('Realizando c\xe1lculo costoso');\n    return contador * 2;\n  }, [contador]);\n\n  const incrementar = useCallback(() => {\n    setContador(prevContador => prevContador + 1);\n  }, []);\n\n  return (\n    <div>\n      <p>Resultado del c\xe1lculo: {calculoCostoso}</p>\n      <button onClick={incrementar}>Incrementar</button>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"\xbfQu\xe9 sucede aqu\xed?"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useMemo"})," memoriza el resultado de un c\xe1lculo costoso y solo lo recalcula si cambia la dependencia (",(0,a.jsx)(n.code,{children:"contador"})," en este caso)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useCallback"})," memoriza la funci\xf3n ",(0,a.jsx)(n.code,{children:"incrementar"}),", evitando que se recree en cada renderizado."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"4-carga-diferida-de-componentes-lazy-loading",children:"4. Carga diferida de componentes (Lazy Loading)"}),"\n",(0,a.jsxs)(n.p,{children:["Otra t\xe9cnica para optimizar el rendimiento es la carga diferida de componentes, especialmente \xfatil en aplicaciones grandes donde no todos los componentes se necesitan al inicio. Para esto, podemos usar ",(0,a.jsx)(n.code,{children:"React.lazy"})," y ",(0,a.jsx)(n.code,{children:"Suspense"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-carga-diferida",children:"Ejemplo b\xe1sico de carga diferida"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React, { Suspense } from 'react';\n\nconst MiComponentePesado = React.lazy(() => import('./MiComponentePesado'));\n\nconst App = () => {\n  return (\n    <div>\n      <Suspense fallback={<div>Cargando...</div>}>\n        <MiComponentePesado />\n      </Suspense>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"\xbfQu\xe9 sucede aqu\xed?"}),(0,a.jsx)(n.br,{}),"\n",(0,a.jsx)(n.code,{children:"MiComponentePesado"})," se cargar\xe1 solo cuando sea necesario, lo que reduce el tiempo de carga inicial de la aplicaci\xf3n."]}),"\n",(0,a.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"React.memo"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"shouldComponentUpdate"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"useMemo"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"useCallback"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Lazy Loading"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"React.lazy"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Suspense"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,a.jsxs)(n.p,{children:["Optimizar el renderizado en React es esencial para mantener una aplicaci\xf3n r\xe1pida y eficiente. Utilizando herramientas como ",(0,a.jsx)(n.code,{children:"React.memo"}),", ",(0,a.jsx)(n.code,{children:"shouldComponentUpdate"}),", ",(0,a.jsx)(n.code,{children:"useMemo"}),", ",(0,a.jsx)(n.code,{children:"useCallback"}),", y la carga diferida, podemos reducir la cantidad de renderizados innecesarios y mejorar significativamente el rendimiento. Aplicar estas t\xe9cnicas te ayudar\xe1 a construir aplicaciones React m\xe1s \xe1giles y con una mejor experiencia de usuario."]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(t,{...e})}):t(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>d});var a=o(6540);const s={},i=a.createContext(s);function c(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);