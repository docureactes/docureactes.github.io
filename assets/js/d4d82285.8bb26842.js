"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[8110],{7603:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var a=r(4848),s=r(8453);const o={},i="Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",d={id:"State/2-7-Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",title:"Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",description:"En el desarrollo con React, useState es una herramienta fundamental para gestionar el estado de un componente, pero hay situaciones en las que otra herramienta llamada useRef puede ser m\xe1s adecuada. En esta lecci\xf3n, vamos a explorar useRef, entendiendo c\xf3mo y cu\xe1ndo usarlo, y por qu\xe9, en ciertos casos, es preferible al uso de useState.",source:"@site/docs/2-State/2-7-Introducci\xf3n a useRef y uso de variables de componente en lugar de useState.md",sourceDirName:"2-State",slug:"/State/2-7-Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",permalink:"/State/2-7-Introducci\xf3n a useRef y uso de variables de componente en lugar de useState",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Simplificaci\xf3n y estructuraci\xf3n de estados relacionados",permalink:"/State/2-6-Simplificaci\xf3n y estructuraci\xf3n de estados relacionados"},next:{title:"Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado",permalink:"/State/2-8-Naturaleza as\xedncrona de la funci\xf3n de actualizaci\xf3n del estado, aprovechamiento del estado anterior y reinicializaci\xf3n del estado"}},t={},c=[{value:"\xbfQu\xe9 es <code>useRef</code>?",id:"qu\xe9-es-useref",level:2},{value:"\xbfC\xf3mo funciona <code>useRef</code>?",id:"c\xf3mo-funciona-useref",level:3},{value:"Explicaci\xf3n del c\xf3digo:",id:"explicaci\xf3n-del-c\xf3digo",level:3},{value:"\xbfCu\xe1ndo usar <code>useRef</code> en lugar de <code>useState</code>?",id:"cu\xe1ndo-usar-useref-en-lugar-de-usestate",level:2},{value:"Ejemplo pr\xe1ctico: Gestionando un temporizador",id:"ejemplo-pr\xe1ctico-gestionando-un-temporizador",level:3},{value:"Explicaci\xf3n del c\xf3digo:",id:"explicaci\xf3n-del-c\xf3digo-1",level:3},{value:"Puntos a tener en cuenta",id:"puntos-a-tener-en-cuenta",level:2},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"introducci\xf3n-a-useref-y-uso-de-variables-de-componente-en-lugar-de-usestate",children:"Introducci\xf3n a useRef y uso de variables de componente en lugar de useState"}),"\n",(0,a.jsxs)(n.p,{children:["En el desarrollo con React, ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})})," es una herramienta fundamental para gestionar el estado de un componente, pero hay situaciones en las que otra herramienta llamada ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," puede ser m\xe1s adecuada. En esta lecci\xf3n, vamos a explorar ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})}),", entendiendo c\xf3mo y cu\xe1ndo usarlo, y por qu\xe9, en ciertos casos, es preferible al uso de ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})}),"."]}),"\n",(0,a.jsxs)(n.h2,{id:"qu\xe9-es-useref",children:["\xbfQu\xe9 es ",(0,a.jsx)(n.code,{children:"useRef"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," es un Hook en React que te permite crear una referencia mutable que persiste entre renderizados. Esta referencia puede ser utilizada para acceder directamente a elementos del DOM o para guardar valores que no necesitan provocar un re-renderizado del componente cuando cambian."]}),"\n",(0,a.jsxs)(n.h3,{id:"c\xf3mo-funciona-useref",children:["\xbfC\xf3mo funciona ",(0,a.jsx)(n.code,{children:"useRef"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:["Cuando usas ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})}),", obtienes un objeto con una propiedad ",(0,a.jsx)(n.code,{children:".current"})," que puedes modificar sin causar un re-renderizado del componente. Este comportamiento lo diferencia de ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})}),", que provoca un re-renderizado cada vez que su valor cambia."]}),"\n",(0,a.jsx)(n.p,{children:"Veamos un ejemplo simple para ilustrar su uso:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React, { useRef, useState } from 'react';\n\nfunction Contador() {\n  const [contador, setContador] = useState(0); // Estado para el contador\n  const renders = useRef(0); // Referencia para contar renderizados\n\n  renders.current++; // Incrementa el contador de renderizados en cada render\n\n  return (\n    <div>\n      <p>Contador: {contador}</p>\n      <p>Renderizado {renders.current} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Incrementar contador\n      </button>\n    </div>\n  );\n}\n\nexport default Contador;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"explicaci\xf3n-del-c\xf3digo",children:"Explicaci\xf3n del c\xf3digo:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})})," se utiliza para gestionar el valor del contador, que cambia cuando se hace clic en el bot\xf3n."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," se utiliza para contar cu\xe1ntas veces se ha renderizado el componente. A diferencia de ",(0,a.jsx)(n.code,{children:"useState"}),", modificar ",(0,a.jsx)(n.code,{children:"renders.current"})," no provoca un re-renderizado, lo que es \xfatil cuando solo necesitas almacenar un valor entre renderizados sin afectar el flujo de la UI."]}),"\n"]}),"\n",(0,a.jsxs)(n.h2,{id:"cu\xe1ndo-usar-useref-en-lugar-de-usestate",children:["\xbfCu\xe1ndo usar ",(0,a.jsx)(n.code,{children:"useRef"})," en lugar de ",(0,a.jsx)(n.code,{children:"useState"}),"?"]}),"\n",(0,a.jsxs)(n.p,{children:["Existen ciertas situaciones donde es m\xe1s conveniente utilizar ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," en lugar de ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})}),":"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Valores que no afectan la UI"}),": Si el valor que est\xe1s manejando no debe causar un re-renderizado del componente, ",(0,a.jsx)(n.code,{children:"useRef"})," es la mejor opci\xf3n. Ejemplos incluyen contadores de renderizados, valores temporales, y cualquier dato que no se muestre directamente en la interfaz."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Persistencia entre renderizados"}),": ",(0,a.jsx)(n.code,{children:"useRef"})," te permite mantener valores entre renderizados sin provocar re-renderizados adicionales. Esto es \xfatil para optimizar el rendimiento de tu componente, especialmente cuando el valor que est\xe1s manejando cambia con frecuencia pero no necesita actualizar la UI."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Acceso al DOM"}),": ",(0,a.jsx)(n.code,{children:"useRef"})," tambi\xe9n se utiliza para acceder directamente a elementos del DOM, lo que es \xfatil cuando necesitas manipular elementos de la interfaz de usuario de manera imperativa."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"ejemplo-pr\xe1ctico-gestionando-un-temporizador",children:"Ejemplo pr\xe1ctico: Gestionando un temporizador"}),"\n",(0,a.jsxs)(n.p,{children:["Vamos a crear un componente que utiliza ",(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," para gestionar un temporizador sin que la UI se re-renderice constantemente:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"import React, { useRef, useState } from 'react';\n\nfunction Temporizador() {\n  const [tiempo, setTiempo] = useState(0); // Estado para mostrar el tiempo\n  const intervalRef = useRef(null); // Referencia para guardar el ID del intervalo\n\n  const iniciarTemporizador = () => {\n    intervalRef.current = setInterval(() => {\n      setTiempo(prevTiempo => prevTiempo + 1);\n    }, 1000);\n  };\n\n  const detenerTemporizador = () => {\n    clearInterval(intervalRef.current);\n  };\n\n  return (\n    <div>\n      <p>Tiempo: {tiempo} segundos</p>\n      <button onClick={iniciarTemporizador}>Iniciar</button>\n      <button onClick={detenerTemporizador}>Detener</button>\n    </div>\n  );\n}\n\nexport default Temporizador;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"explicaci\xf3n-del-c\xf3digo-1",children:"Explicaci\xf3n del c\xf3digo:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useState"})})," se usa para el estado que se muestra en la UI, en este caso, el tiempo transcurrido."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useRef"})})," almacena el ID del intervalo del temporizador, permitiendo detener el temporizador sin que la UI se vuelva a renderizar innecesariamente."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"puntos-a-tener-en-cuenta",children:"Puntos a tener en cuenta"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No provoca re-renderizado"}),": Cualquier cambio en ",(0,a.jsx)(n.code,{children:".current"})," de ",(0,a.jsx)(n.code,{children:"useRef"})," no causar\xe1 un nuevo renderizado del componente."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Persistencia"}),": Los valores guardados en ",(0,a.jsx)(n.code,{children:"useRef"})," persistir\xe1n durante toda la vida del componente, similar a los valores de estado."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Uso en el DOM"}),": ",(0,a.jsx)(n.code,{children:"useRef"})," es ideal para trabajar con referencias directas a elementos del DOM."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"useState vs useRef"}),": \xbfCu\xe1ndo es mejor usar cada uno?"]}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Manipulaci\xf3n del DOM con useRef"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.strong,{children:"Optimizaci\xf3n del rendimiento en React"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"useRef"})," es una herramienta poderosa en React que te permite crear referencias mutables que persisten entre renderizados sin provocar un re-renderizado del componente. Es ideal para manejar valores que no afectan la UI, acceder a elementos del DOM y optimizar el rendimiento de tus componentes. En comparaci\xf3n con ",(0,a.jsx)(n.code,{children:"useState"}),", ",(0,a.jsx)(n.code,{children:"useRef"})," se utiliza cuando necesitas mantener valores entre renderizados sin que estos causen actualizaciones visuales."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>d});var a=r(6540);const s={},o=a.createContext(s);function i(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);