"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6413],{3941:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var r=o(4848),s=o(8453);const i={},c="useMemo",a={id:"Hook/7-4-useMemo",title:"useMemo",description:"\xbfQu\xe9 es useMemo?",source:"@site/docs/7-Hook/7-4-useMemo.md",sourceDirName:"7-Hook",slug:"/Hook/7-4-useMemo",permalink:"/Hook/7-4-useMemo",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useCallback",permalink:"/Hook/7-3-useCallback"},next:{title:"useReducer",permalink:"/Hook/7-5-useReducer"}},l={},d=[{value:"\xbfQu\xe9 es <code>useMemo</code>?",id:"qu\xe9-es-usememo",level:2},{value:"\xbfC\xf3mo funciona <code>useMemo</code>?",id:"c\xf3mo-funciona-usememo",level:3},{value:"Ejemplo b\xe1sico de <code>useMemo</code>",id:"ejemplo-b\xe1sico-de-usememo",level:3},{value:"Explicaci\xf3n del ejemplo",id:"explicaci\xf3n-del-ejemplo",level:3},{value:"\xbfCu\xe1ndo usar <code>useMemo</code>?",id:"cu\xe1ndo-usar-usememo",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"usememo",children:"useMemo"}),"\n",(0,r.jsxs)(n.h2,{id:"qu\xe9-es-usememo",children:["\xbfQu\xe9 es ",(0,r.jsx)(n.code,{children:"useMemo"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMemo"})," es un ",(0,r.jsx)(n.strong,{children:"Hook de React"}),' que te permite memorizar ("cachear") el valor calculado de una funci\xf3n, para evitar que esta se ejecute innecesariamente en cada renderizado del componente. Es especialmente \xfatil cuando la funci\xf3n es costosa en t\xe9rminos de rendimiento, es decir, cuando realiza c\xe1lculos complejos o procesa una gran cantidad de datos.']}),"\n",(0,r.jsxs)(n.h3,{id:"c\xf3mo-funciona-usememo",children:["\xbfC\xf3mo funciona ",(0,r.jsx)(n.code,{children:"useMemo"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMemo"})," toma dos argumentos:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Una funci\xf3n"}),": Esta funci\xf3n contiene la l\xf3gica para calcular el valor que queremos memorizar."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Un array de dependencias"}),": Son las variables que, cuando cambian, provocan que la funci\xf3n se vuelva a ejecutar y se recalcule el valor memorizado."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"React ejecutar\xe1 la funci\xf3n solo si alguna de las dependencias cambia. Si ninguna dependencia cambia, React devolver\xe1 el valor memorizado de la \xfaltima vez que se ejecut\xf3 la funci\xf3n."}),"\n",(0,r.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-usememo",children:["Ejemplo b\xe1sico de ",(0,r.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,r.jsxs)(n.p,{children:["Imaginemos que tenemos un componente que realiza un c\xe1lculo costoso, como encontrar el n\xfamero primo m\xe1s grande por debajo de un n\xfamero dado. Sin ",(0,r.jsx)(n.code,{children:"useMemo"}),", esta funci\xf3n se ejecutar\xeda cada vez que el componente se renderice, lo cual puede ralentizar nuestra aplicaci\xf3n si el c\xe1lculo es complejo."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import React, { useMemo, useState } from 'react';\n\n// Funci\xf3n para encontrar el n\xfamero primo m\xe1s grande por debajo de un n\xfamero dado\nfunction encontrarMayorPrimo(n) {\n  let mayorPrimo = 2;\n  for (let i = 2; i <= n; i++) {\n    if (esPrimo(i)) {\n      mayorPrimo = i;\n    }\n  }\n  return mayorPrimo;\n}\n\n// Funci\xf3n auxiliar para verificar si un n\xfamero es primo\nfunction esPrimo(n) {\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) {\n      return false;\n    }\n  }\n  return n > 1;\n}\n\nfunction ComponentePrimo() {\n  const [numero, setNumero] = useState(100000);\n\n  // Memorizar el valor del mayor primo utilizando useMemo\n  const mayorPrimo = useMemo(() => encontrarMayorPrimo(numero), [numero]);\n\n  return (\n    <div>\n      <h2>El n\xfamero primo m\xe1s grande por debajo de {numero} es: {mayorPrimo}</h2>\n      <button onClick={() => setNumero(numero + 1000)}>Incrementar n\xfamero</button>\n    </div>\n  );\n}\n\nexport default ComponentePrimo;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"explicaci\xf3n-del-ejemplo",children:"Explicaci\xf3n del ejemplo"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Funci\xf3n ",(0,r.jsx)(n.code,{children:"encontrarMayorPrimo"})]}),": Esta funci\xf3n realiza un c\xe1lculo costoso, ya que tiene que recorrer todos los n\xfameros hasta ",(0,r.jsx)(n.code,{children:"n"})," para encontrar el n\xfamero primo m\xe1s grande."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Uso de ",(0,r.jsx)(n.code,{children:"useMemo"})]}),": Al usar ",(0,r.jsx)(n.code,{children:"useMemo"}),", estamos indicando a React que memorice el resultado de ",(0,r.jsx)(n.code,{children:"encontrarMayorPrimo(numero)"}),". Esto significa que solo se recalcular\xe1 cuando ",(0,r.jsx)(n.code,{children:"numero"})," cambie."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimizaci\xf3n del rendimiento"}),": Si ",(0,r.jsx)(n.code,{children:"numero"})," no cambia, el componente se renderizar\xe1 r\xe1pidamente porque no es necesario volver a calcular el n\xfamero primo."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"cu\xe1ndo-usar-usememo",children:["\xbfCu\xe1ndo usar ",(0,r.jsx)(n.code,{children:"useMemo"}),"?"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Usa ",(0,r.jsx)(n.code,{children:"useMemo"})," cuando:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tienes c\xe1lculos costosos que no deben ejecutarse en cada renderizado."}),"\n",(0,r.jsx)(n.li,{children:"Quieres optimizar el rendimiento de tu aplicaci\xf3n, especialmente en componentes que se renderizan con frecuencia."}),"\n",(0,r.jsx)(n.li,{children:"Tienes una funci\xf3n que depende de datos externos (como el estado o las props) y que solo deber\xeda recalcularse cuando esos datos cambien."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Evita ",(0,r.jsx)(n.code,{children:"useMemo"})," cuando:"]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"El c\xe1lculo es trivial y no impacta significativamente en el rendimiento."}),"\n",(0,r.jsxs)(n.li,{children:["El c\xf3digo es lo suficientemente simple sin ",(0,r.jsx)(n.code,{children:"useMemo"})," y su inclusi\xf3n lo har\xeda m\xe1s complejo innecesariamente."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Hooks en React"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Optimizaci\xf3n de rendimiento"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"useCallback"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Memorizaci\xf3n en programaci\xf3n"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Renderizado en React"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useMemo"})," es un Hook poderoso que te permite optimizar el rendimiento de tus componentes en React al memorizar resultados de c\xe1lculos costosos. Solo se recalcula el valor cuando cambian las dependencias especificadas, lo que puede mejorar significativamente la eficiencia de la aplicaci\xf3n en escenarios complejos. Es importante usar ",(0,r.jsx)(n.code,{children:"useMemo"})," de manera estrat\xe9gica para obtener beneficios reales sin complicar innecesariamente el c\xf3digo."]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>a});var r=o(6540);const s={},i=r.createContext(s);function c(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);