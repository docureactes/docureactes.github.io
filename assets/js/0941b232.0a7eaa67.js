"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[3036],{7742:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=a(4848),i=a(8453);const s={},c="T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",r={id:"Optimizaci\xf3n/8-1-T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",title:"T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",description:"Cuando trabajas con React, uno de los principales retos es mantener el rendimiento \xf3ptimo de tus componentes a medida que tu aplicaci\xf3n crece. React hace un gran trabajo optimizando el renderizado de los componentes, pero hay situaciones en las que puedes aplicar t\xe9cnicas adicionales para asegurarte de que tu aplicaci\xf3n sigue siendo r\xe1pida y eficiente. En este apartado, exploraremos algunas de las mejores pr\xe1cticas y estrategias para optimizar el rendimiento de los componentes en React.",source:"@site/docs/8-Optimizaci\xf3n/8-1-T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes.md",sourceDirName:"8-Optimizaci\xf3n",slug:"/Optimizaci\xf3n/8-1-T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",permalink:"/Optimizaci\xf3n/8-1-T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hooks personalizados",permalink:"/Hook/7-9-Hooks personalizados"},next:{title:"T\xe9cnicas de optimizaci\xf3n del renderizado",permalink:"/Optimizaci\xf3n/8-2-T\xe9cnicas de optimizaci\xf3n del renderizado"}},d={},l=[{value:"Evitar el renderizado innecesario",id:"evitar-el-renderizado-innecesario",level:2},{value:"<code>React.memo</code>",id:"reactmemo",level:3},{value:"Usar <code>useCallback</code> y <code>useMemo</code>",id:"usar-usecallback-y-usememo",level:2},{value:"<code>useCallback</code>",id:"usecallback",level:3},{value:"<code>useMemo</code>",id:"usememo",level:3},{value:"Evitar c\xe1lculos costosos durante el renderizado",id:"evitar-c\xe1lculos-costosos-durante-el-renderizado",level:2},{value:"Divisi\xf3n de c\xf3digo y carga diferida (Code Splitting)",id:"divisi\xf3n-de-c\xf3digo-y-carga-diferida-code-splitting",level:2},{value:"<code>React.lazy</code> y <code>Suspense</code>",id:"reactlazy-y-suspense",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function t(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"t\xe9cnicas-de-optimizaci\xf3n-del-rendimiento-de-componentes",children:"T\xe9cnicas de optimizaci\xf3n del rendimiento de componentes"}),"\n",(0,o.jsx)(n.p,{children:"Cuando trabajas con React, uno de los principales retos es mantener el rendimiento \xf3ptimo de tus componentes a medida que tu aplicaci\xf3n crece. React hace un gran trabajo optimizando el renderizado de los componentes, pero hay situaciones en las que puedes aplicar t\xe9cnicas adicionales para asegurarte de que tu aplicaci\xf3n sigue siendo r\xe1pida y eficiente. En este apartado, exploraremos algunas de las mejores pr\xe1cticas y estrategias para optimizar el rendimiento de los componentes en React."}),"\n",(0,o.jsx)(n.h2,{id:"evitar-el-renderizado-innecesario",children:"Evitar el renderizado innecesario"}),"\n",(0,o.jsx)(n.p,{children:"Una de las formas m\xe1s sencillas de mejorar el rendimiento es evitar que los componentes se vuelvan a renderizar cuando no es necesario. Cada vez que un componente se renderiza, React compara el nuevo \xe1rbol de elementos con el anterior, lo que puede consumir recursos si se hace con demasiada frecuencia."}),"\n",(0,o.jsx)(n.h3,{id:"reactmemo",children:(0,o.jsx)(n.code,{children:"React.memo"})}),"\n",(0,o.jsxs)(n.p,{children:["Una herramienta poderosa para evitar el renderizado innecesario es ",(0,o.jsx)(n.code,{children:"React.memo"}),". Este es un ",(0,o.jsx)(n.strong,{children:"Higher Order Component (HOC)"})," que memoriza el resultado de un componente funcional y evita su re-renderizado si sus props no han cambiado."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React from 'react';\n\n// Componente simple que solo necesita renderizarse cuando sus props cambian\nconst MiComponente = React.memo(({ valor }) => {\n  console.log('Renderizando MiComponente');\n  return <div>{valor}</div>;\n});\n\nexport default MiComponente;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["En este ejemplo, ",(0,o.jsx)(n.code,{children:"MiComponente"})," solo se renderizar\xe1 si la prop ",(0,o.jsx)(n.code,{children:"valor"})," cambia. Esto puede ser muy \xfatil para componentes que reciben datos que no cambian con frecuencia."]}),"\n",(0,o.jsxs)(n.h2,{id:"usar-usecallback-y-usememo",children:["Usar ",(0,o.jsx)(n.code,{children:"useCallback"})," y ",(0,o.jsx)(n.code,{children:"useMemo"})]}),"\n",(0,o.jsx)(n.h3,{id:"usecallback",children:(0,o.jsx)(n.code,{children:"useCallback"})}),"\n",(0,o.jsxs)(n.p,{children:["Cuando pasas funciones como props a componentes hijos, es importante que esas funciones no se redefinan en cada renderizado, ya que esto podr\xeda forzar un renderizado innecesario de los componentes hijos. Aqu\xed es donde ",(0,o.jsx)(n.code,{children:"useCallback"})," entra en juego."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React, { useCallback, useState } from 'react';\n\nconst Boton = React.memo(({ handleClick }) => {\n  console.log('Renderizando Boton');\n  return <button onClick={handleClick}>Haz clic</button>;\n});\n\nconst Contador = () => {\n  const [cuenta, setCuenta] = useState(0);\n\n  // useCallback asegura que la funci\xf3n handleClick no se redefina en cada renderizado\n  const handleClick = useCallback(() => {\n    setCuenta(cuenta + 1);\n  }, [cuenta]);\n\n  return (\n    <div>\n      <Boton handleClick={handleClick} />\n      <p>Cuenta: {cuenta}</p>\n    </div>\n  );\n};\n\nexport default Contador;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["En este caso, ",(0,o.jsx)(n.code,{children:"useCallback"})," asegura que ",(0,o.jsx)(n.code,{children:"handleClick"})," no cambie a menos que ",(0,o.jsx)(n.code,{children:"cuenta"})," cambie, evitando renderizados innecesarios del componente ",(0,o.jsx)(n.code,{children:"Boton"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"usememo",children:(0,o.jsx)(n.code,{children:"useMemo"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMemo"})," es \xfatil para memorizar valores calculados que son costosos de calcular. Al igual que ",(0,o.jsx)(n.code,{children:"useCallback"}),", solo recalcula el valor cuando sus dependencias cambian."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React, { useMemo, useState } from 'react';\n\nconst ComponenteCostoso = ({ valor }) => {\n  console.log('Renderizando ComponenteCostoso');\n  const resultado = useMemo(() => {\n    // Simulaci\xf3n de un c\xe1lculo costoso\n    return valor ** 2;\n  }, [valor]);\n\n  return <div>Resultado: {resultado}</div>;\n};\n\nconst App = () => {\n  const [valor, setValor] = useState(2);\n\n  return (\n    <div>\n      <button onClick={() => setValor(valor + 1)}>Incrementar</button>\n      <ComponenteCostoso valor={valor} />\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Aqu\xed, ",(0,o.jsx)(n.code,{children:"useMemo"})," evita que ",(0,o.jsx)(n.code,{children:"ComponenteCostoso"})," realice el c\xe1lculo a menos que ",(0,o.jsx)(n.code,{children:"valor"})," cambie, mejorando as\xed el rendimiento."]}),"\n",(0,o.jsx)(n.h2,{id:"evitar-c\xe1lculos-costosos-durante-el-renderizado",children:"Evitar c\xe1lculos costosos durante el renderizado"}),"\n",(0,o.jsx)(n.p,{children:"Es fundamental evitar realizar c\xe1lculos intensivos o complejos directamente en el cuerpo de la funci\xf3n de un componente, ya que estos c\xe1lculos se ejecutan cada vez que el componente se renderiza."}),"\n",(0,o.jsxs)(n.p,{children:["En lugar de eso, puedes usar ",(0,o.jsx)(n.code,{children:"useMemo"})," o mover estos c\xe1lculos fuera del ciclo de renderizado, asegurando que solo se ejecuten cuando sea necesario."]}),"\n",(0,o.jsx)(n.h2,{id:"divisi\xf3n-de-c\xf3digo-y-carga-diferida-code-splitting",children:"Divisi\xf3n de c\xf3digo y carga diferida (Code Splitting)"}),"\n",(0,o.jsx)(n.p,{children:"A medida que las aplicaciones crecen, es posible que algunas partes del c\xf3digo no se necesiten de inmediato. La divisi\xf3n de c\xf3digo y la carga diferida permiten que solo se carguen los m\xf3dulos necesarios para la vista actual, mejorando el tiempo de carga inicial."}),"\n",(0,o.jsxs)(n.h3,{id:"reactlazy-y-suspense",children:[(0,o.jsx)(n.code,{children:"React.lazy"})," y ",(0,o.jsx)(n.code,{children:"Suspense"})]}),"\n",(0,o.jsxs)(n.p,{children:["React proporciona ",(0,o.jsx)(n.code,{children:"React.lazy"})," para cargar componentes de manera diferida y ",(0,o.jsx)(n.code,{children:"Suspense"})," para manejar la carga de estos componentes."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Ejemplo:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import React, { Suspense } from 'react';\n\n// Importaci\xf3n diferida del componente\nconst MiComponentePesado = React.lazy(() => import('./MiComponentePesado'));\n\nconst App = () => {\n  return (\n    <div>\n      <Suspense fallback={<div>Cargando...</div>}>\n        <MiComponentePesado />\n      </Suspense>\n    </div>\n  );\n};\n\nexport default App;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["En este ejemplo, ",(0,o.jsx)(n.code,{children:"MiComponentePesado"}),' solo se carga cuando es necesario, y mientras se carga, se muestra un mensaje de "Cargando...". Esto mejora el rendimiento al reducir la carga inicial de la aplicaci\xf3n.']}),"\n",(0,o.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React.memo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"useCallback"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"useMemo"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"React.lazy"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Suspense"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,o.jsxs)(n.p,{children:["Optimizar el rendimiento de los componentes en React es crucial para crear aplicaciones r\xe1pidas y eficientes. T\xe9cnicas como ",(0,o.jsx)(n.code,{children:"React.memo"}),", ",(0,o.jsx)(n.code,{children:"useCallback"}),", ",(0,o.jsx)(n.code,{children:"useMemo"}),", y la carga diferida mediante ",(0,o.jsx)(n.code,{children:"React.lazy"})," pueden ayudar a reducir renderizados innecesarios y mejorar la experiencia del usuario. Aplicar estas t\xe9cnicas adecuadamente puede marcar una gran diferencia en el rendimiento general de tu aplicaci\xf3n."]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(t,{...e})}):t(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>r});var o=a(6540);const i={},s=o.createContext(i);function c(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);