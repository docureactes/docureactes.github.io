"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[3799],{7337:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>t,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var o=s(4848),c=s(8453);const a={},t="Revisi\xf3n de useState, useRef, useEffect",r={id:"Hook/7-1-Revisi\xf3n de useState, useRef, useEffect",title:"Revisi\xf3n de useState, useRef, useEffect",description:"Cuando trabajas con React, te encontrar\xe1s frecuentemente con tres hooks fundamentales: useState, useRef, y useEffect. Estos hooks son herramientas clave que te permiten gestionar el estado, interactuar con referencias a elementos del DOM, y controlar efectos secundarios en tus componentes de React. En esta secci\xf3n, revisaremos cada uno de estos hooks con ejemplos claros para que puedas entender c\xf3mo y cu\xe1ndo utilizarlos.",source:"@site/docs/7-Hook/7-1-Revisi\xf3n de useState, useRef, useEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-1-Revisi\xf3n de useState, useRef, useEffect",permalink:"/Hook/7-1-Revisi\xf3n de useState, useRef, useEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Renderizado din\xe1mico y condicional",permalink:"/Renderizado/6-5-Renderizado din\xe1mico y condicional"},next:{title:"Tipos de retornos de Hooks personalizados",permalink:"/Hook/7-10-Tipos de retornos de Hooks personalizados"}},i={},d=[{value:"useState: Gesti\xf3n del Estado",id:"usestate-gesti\xf3n-del-estado",level:2},{value:"Ejemplo B\xe1sico de useState",id:"ejemplo-b\xe1sico-de-usestate",level:3},{value:"Conceptos Clave",id:"conceptos-clave",level:3},{value:"useRef: Referencias a Elementos y Valores Persistentes",id:"useref-referencias-a-elementos-y-valores-persistentes",level:2},{value:"Ejemplo B\xe1sico de useRef",id:"ejemplo-b\xe1sico-de-useref",level:3},{value:"Conceptos Clave",id:"conceptos-clave-1",level:3},{value:"useEffect: Efectos Secundarios y Ciclo de Vida",id:"useeffect-efectos-secundarios-y-ciclo-de-vida",level:2},{value:"Ejemplo B\xe1sico de useEffect",id:"ejemplo-b\xe1sico-de-useeffect",level:3},{value:"Conceptos Clave",id:"conceptos-clave-2",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"revisi\xf3n-de-usestate-useref-useeffect",children:"Revisi\xf3n de useState, useRef, useEffect"}),"\n",(0,o.jsxs)(n.p,{children:["Cuando trabajas con React, te encontrar\xe1s frecuentemente con tres hooks fundamentales: ",(0,o.jsx)(n.code,{children:"useState"}),", ",(0,o.jsx)(n.code,{children:"useRef"}),", y ",(0,o.jsx)(n.code,{children:"useEffect"}),". Estos hooks son herramientas clave que te permiten gestionar el estado, interactuar con referencias a elementos del DOM, y controlar efectos secundarios en tus componentes de React. En esta secci\xf3n, revisaremos cada uno de estos hooks con ejemplos claros para que puedas entender c\xf3mo y cu\xe1ndo utilizarlos."]}),"\n",(0,o.jsx)(n.h2,{id:"usestate-gesti\xf3n-del-estado",children:"useState: Gesti\xf3n del Estado"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useState"})," es el hook que te permite a\xf1adir estado a un componente funcional. Esto es especialmente \xfatil cuando necesitas que tu componente recuerde alguna informaci\xf3n entre renderizados."]}),"\n",(0,o.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-usestate",children:"Ejemplo B\xe1sico de useState"}),"\n",(0,o.jsx)(n.p,{children:"Imagina que est\xe1s construyendo un contador que se incrementa cada vez que haces clic en un bot\xf3n:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import React, { useState } from 'react';\n\nfunction Contador() {\n  // Declaraci\xf3n de una variable de estado llamada \"contador\" y una funci\xf3n para actualizarla\n  const [contador, setContador] = useState(0);\n\n  return (\n    <div>\n      <p>Has hecho clic {contador} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Incrementar\n      </button>\n    </div>\n  );\n}\n\nexport default Contador;\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"\xbfQu\xe9 est\xe1 pasando aqu\xed?"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useState(0)"})," inicializa el estado ",(0,o.jsx)(n.code,{children:"contador"})," con un valor de ",(0,o.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"setContador"})," es la funci\xf3n que usas para actualizar ese estado."]}),"\n",(0,o.jsxs)(n.li,{children:["Cada vez que el bot\xf3n es clicado, ",(0,o.jsx)(n.code,{children:"setContador"})," incrementa el valor de ",(0,o.jsx)(n.code,{children:"contador"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"conceptos-clave",children:"Conceptos Clave"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inicializaci\xf3n del estado"}),": ",(0,o.jsx)(n.code,{children:"useState"})," siempre debe ser llamado con un valor inicial."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Renderizaci\xf3n"}),": Cada vez que cambias el estado, el componente se renderiza de nuevo mostrando el estado actualizado."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"useref-referencias-a-elementos-y-valores-persistentes",children:"useRef: Referencias a Elementos y Valores Persistentes"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useRef"})," se utiliza para crear referencias a elementos del DOM o para almacenar valores que quieres que persistan entre renderizados sin causar una nueva renderizaci\xf3n del componente."]}),"\n",(0,o.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-useref",children:"Ejemplo B\xe1sico de useRef"}),"\n",(0,o.jsx)(n.p,{children:"Considera un caso donde quieres enfocar un input de texto autom\xe1ticamente cuando se carga el componente:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import React, { useRef, useEffect } from 'react';\n\nfunction EnfocarInput() {\n  const inputRef = useRef(null);\n\n  useEffect(() => {\n    // Enfocar el input cuando el componente se monta\n    inputRef.current.focus();\n  }, []);\n\n  return <input ref={inputRef} type=\"text\" />;\n}\n\nexport default EnfocarInput;\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"\xbfQu\xe9 est\xe1 pasando aqu\xed?"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useRef(null)"})," crea una referencia que inicialmente es ",(0,o.jsx)(n.code,{children:"null"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"inputRef.current"})," accede al elemento DOM actual."]}),"\n",(0,o.jsxs)(n.li,{children:["El input es enfocado autom\xe1ticamente al montar el componente gracias a ",(0,o.jsx)(n.code,{children:"useEffect"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"conceptos-clave-1",children:"Conceptos Clave"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Persistencia de valores"}),": ",(0,o.jsx)(n.code,{children:"useRef"})," no causa que el componente se renderice nuevamente cuando el valor de la referencia cambia."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Acceso al DOM"}),": ",(0,o.jsx)(n.code,{children:"useRef"})," es una manera com\xfan de interactuar directamente con los elementos del DOM."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"useeffect-efectos-secundarios-y-ciclo-de-vida",children:"useEffect: Efectos Secundarios y Ciclo de Vida"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useEffect"})," se utiliza para manejar efectos secundarios en tus componentes, como operaciones de red, suscripciones, o manipulaci\xf3n directa del DOM que necesitan ocurrir despu\xe9s de que un componente se haya renderizado."]}),"\n",(0,o.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-useeffect",children:"Ejemplo B\xe1sico de useEffect"}),"\n",(0,o.jsx)(n.p,{children:"Imagina que quieres cambiar el t\xedtulo del documento del navegador cada vez que el contador cambia:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"import React, { useState, useEffect } from 'react';\n\nfunction ContadorConTitulo() {\n  const [contador, setContador] = useState(0);\n\n  useEffect(() => {\n    document.title = `Clics: ${contador}`;\n  }, [contador]); // Solo ejecutar el efecto cuando \"contador\" cambie\n\n  return (\n    <div>\n      <p>Has hecho clic {contador} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Incrementar\n      </button>\n    </div>\n  );\n}\n\nexport default ContadorConTitulo;\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"\xbfQu\xe9 est\xe1 pasando aqu\xed?"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useEffect"})," se ejecuta despu\xe9s de cada renderizaci\xf3n, actualizando el t\xedtulo del documento."]}),"\n",(0,o.jsxs)(n.li,{children:["El segundo argumento ",(0,o.jsx)(n.code,{children:"[contador]"})," es una lista de dependencias que indica cu\xe1ndo debe ejecutarse el efecto. En este caso, solo se ejecutar\xe1 cuando ",(0,o.jsx)(n.code,{children:"contador"})," cambie."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"conceptos-clave-2",children:"Conceptos Clave"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Efectos dependientes"}),": Usa el segundo argumento de ",(0,o.jsx)(n.code,{children:"useEffect"})," para controlar cu\xe1ndo se ejecuta."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Limpieza de efectos"}),": Si un efecto necesita limpiar recursos (por ejemplo, cancelar una suscripci\xf3n), puedes retornar una funci\xf3n dentro de ",(0,o.jsx)(n.code,{children:"useEffect"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Estado y ciclo de vida en React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Referencias al DOM en React"})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.strong,{children:"Efectos secundarios y su gesti\xf3n en componentes funcionales"})}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,o.jsxs)(n.p,{children:["En esta secci\xf3n, hemos revisado tres hooks esenciales de React: ",(0,o.jsx)(n.code,{children:"useState"})," para la gesti\xf3n del estado, ",(0,o.jsx)(n.code,{children:"useRef"})," para mantener referencias y valores persistentes sin renderizar, y ",(0,o.jsx)(n.code,{children:"useEffect"})," para manejar efectos secundarios y controlar el ciclo de vida de los componentes. Cada uno de estos hooks es fundamental para construir componentes din\xe1micos y reactivos, permiti\xe9ndote crear aplicaciones interactivas y eficientes."]})]})}function u(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>r});var o=s(6540);const c={},a=o.createContext(c);function t(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);