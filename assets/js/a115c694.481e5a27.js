"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6403],{7285:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>t,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>d,toc:()=>r});var c=o(4848),s=o(8453);const a={},i="Introducci\xf3n a useEffect y control del ciclo de vida",d={id:"Ciclo de vida/4-1-Introducci\xf3n a useEffect y control del ciclo de vida",title:"Introducci\xf3n a useEffect y control del ciclo de vida",description:"useEffect es uno de los hooks m\xe1s poderosos y utilizados en React. Nos permite gestionar efectos secundarios en componentes funcionales, como la obtenci\xf3n de datos, la suscripci\xf3n a servicios o la manipulaci\xf3n del DOM, asegur\xe1ndonos de que nuestras aplicaciones funcionen de manera correcta y eficiente. Pero, para usar useEffect correctamente, es fundamental entender c\xf3mo funciona el ciclo de vida de un componente en React.",source:"@site/docs/4-Ciclo de vida/4-1-Introducci\xf3n a useEffect y control del ciclo de vida.md",sourceDirName:"4-Ciclo de vida",slug:"/Ciclo de vida/4-1-Introducci\xf3n a useEffect y control del ciclo de vida",permalink:"/Ciclo de vida/4-1-Introducci\xf3n a useEffect y control del ciclo de vida",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"defaultProps",permalink:"/Props/3-9-defaultProps"},next:{title:"Uso de useEffect con funciones con nombre",permalink:"/Ciclo de vida/4-2-Uso de useEffect con funciones con nombre"}},t={},r=[{value:"\xbfQu\xe9 es useEffect?",id:"qu\xe9-es-useeffect",level:2},{value:"Ejemplo b\xe1sico de useEffect",id:"ejemplo-b\xe1sico-de-useeffect",level:3},{value:"Explicaci\xf3n del c\xf3digo",id:"explicaci\xf3n-del-c\xf3digo",level:3},{value:"Limpieza de efectos",id:"limpieza-de-efectos",level:3},{value:"Ciclo de vida del componente y useEffect",id:"ciclo-de-vida-del-componente-y-useeffect",level:3},{value:"Puntos clave a tener en cuenta",id:"puntos-clave-a-tener-en-cuenta",level:3},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h1,{id:"introducci\xf3n-a-useeffect-y-control-del-ciclo-de-vida",children:"Introducci\xf3n a useEffect y control del ciclo de vida"}),"\n",(0,c.jsxs)(n.p,{children:["useEffect es uno de los hooks m\xe1s poderosos y utilizados en React. Nos permite gestionar efectos secundarios en componentes funcionales, como la obtenci\xf3n de datos, la suscripci\xf3n a servicios o la manipulaci\xf3n del DOM, asegur\xe1ndonos de que nuestras aplicaciones funcionen de manera correcta y eficiente. Pero, para usar ",(0,c.jsx)(n.code,{children:"useEffect"})," correctamente, es fundamental entender c\xf3mo funciona el ciclo de vida de un componente en React."]}),"\n",(0,c.jsx)(n.h2,{id:"qu\xe9-es-useeffect",children:"\xbfQu\xe9 es useEffect?"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"useEffect"})," es un hook que nos permite realizar efectos secundarios en los componentes funcionales. Antes de su introducci\xf3n, esta funcionalidad estaba limitada a los componentes de clase mediante los m\xe9todos del ciclo de vida como ",(0,c.jsx)(n.code,{children:"componentDidMount"}),", ",(0,c.jsx)(n.code,{children:"componentDidUpdate"})," y ",(0,c.jsx)(n.code,{children:"componentWillUnmount"}),"."]}),"\n",(0,c.jsx)(n.h3,{id:"ejemplo-b\xe1sico-de-useeffect",children:"Ejemplo b\xe1sico de useEffect"}),"\n",(0,c.jsxs)(n.p,{children:["Veamos un ejemplo b\xe1sico que muestra c\xf3mo usar ",(0,c.jsx)(n.code,{children:"useEffect"})," para realizar una acci\xf3n despu\xe9s de que el componente se ha renderizado por primera vez:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-jsx",children:"import React, { useState, useEffect } from 'react';\n\nfunction Contador() {\n  const [contador, setContador] = useState(0);\n\n  // useEffect se ejecuta despu\xe9s de cada renderizado\n  useEffect(() => {\n    console.log(\"El componente se ha renderizado o el contador ha cambiado\");\n  }, [contador]); // El efecto se ejecutar\xe1 solo cuando cambie el valor de 'contador'\n\n  return (\n    <div>\n      <p>Has hecho clic {contador} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Incrementar contador\n      </button>\n    </div>\n  );\n}\n\nexport default Contador;\n"})}),"\n",(0,c.jsx)(n.h3,{id:"explicaci\xf3n-del-c\xf3digo",children:"Explicaci\xf3n del c\xf3digo"}),"\n",(0,c.jsxs)(n.ol,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"useEffect con dependencias:"})," En el ejemplo anterior, ",(0,c.jsx)(n.code,{children:"useEffect"})," se ejecuta cada vez que el valor de ",(0,c.jsx)(n.code,{children:"contador"})," cambia. Esto es porque hemos pasado ",(0,c.jsx)(n.code,{children:"[contador]"})," como segundo argumento, que es la lista de dependencias. Si dej\xe1ramos esta lista vac\xeda ",(0,c.jsx)(n.code,{children:"[]"}),", ",(0,c.jsx)(n.code,{children:"useEffect"})," solo se ejecutar\xeda una vez, despu\xe9s del primer renderizado."]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.strong,{children:"Efecto secundario:"})," En este caso, el efecto secundario es simplemente un ",(0,c.jsx)(n.code,{children:"console.log"}),", pero podr\xeda ser cualquier otra cosa, como una llamada a una API, una suscripci\xf3n o incluso la manipulaci\xf3n del DOM."]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"limpieza-de-efectos",children:"Limpieza de efectos"}),"\n",(0,c.jsxs)(n.p,{children:["Algunos efectos necesitan ser limpiados para evitar fugas de memoria, especialmente cuando estamos manejando suscripciones o temporizadores. ",(0,c.jsx)(n.code,{children:"useEffect"})," puede devolver una funci\xf3n que React llamar\xe1 cuando sea necesario limpiar el efecto:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-jsx",children:'useEffect(() => {\n  const timer = setInterval(() => {\n    console.log("Contador activo");\n  }, 1000);\n\n  // Funci\xf3n de limpieza que se ejecuta cuando el componente se desmonta o se actualiza\n  return () => {\n    clearInterval(timer);\n    console.log("Contador detenido");\n  };\n}, []); // Al pasar una lista vac\xeda, este efecto solo se ejecuta una vez, cuando el componente se monta\n'})}),"\n",(0,c.jsx)(n.h3,{id:"ciclo-de-vida-del-componente-y-useeffect",children:"Ciclo de vida del componente y useEffect"}),"\n",(0,c.jsxs)(n.p,{children:["Para entender mejor ",(0,c.jsx)(n.code,{children:"useEffect"}),", es \xfatil conocer c\xf3mo se relaciona con el ciclo de vida del componente:"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Montaje (Mount):"})," Ocurre cuando el componente se renderiza por primera vez. ",(0,c.jsx)(n.code,{children:"useEffect"})," con una lista vac\xeda ",(0,c.jsx)(n.code,{children:"[]"})," se ejecuta en este punto."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Actualizaci\xf3n (Update):"})," Ocurre cuando el estado o las props del componente cambian. ",(0,c.jsx)(n.code,{children:"useEffect"})," con dependencias se ejecutar\xe1 en este punto si alguna de esas dependencias ha cambiado."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Desmontaje (Unmount):"})," Ocurre cuando el componente se elimina del DOM. Aqu\xed es donde la funci\xf3n de limpieza dentro de ",(0,c.jsx)(n.code,{children:"useEffect"})," es \xfatil."]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"puntos-clave-a-tener-en-cuenta",children:"Puntos clave a tener en cuenta"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Evita efectos sin dependencias:"})," Un ",(0,c.jsx)(n.code,{children:"useEffect"})," sin dependencias se ejecutar\xe1 despu\xe9s de cada renderizado, lo que podr\xeda afectar el rendimiento."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Usa la funci\xf3n de limpieza:"})," Siempre que tu efecto involucre una suscripci\xf3n o un temporizador, aseg\xfarate de limpiarlo para evitar fugas de memoria."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Cuida el orden de las dependencias:"})," El orden y la inclusi\xf3n correcta de las dependencias en la lista de ",(0,c.jsx)(n.code,{children:"useEffect"})," es crucial para que el componente funcione como se espera."]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"Hooks en React"}),"\n",(0,c.jsx)(n.li,{children:"Efectos secundarios"}),"\n",(0,c.jsx)(n.li,{children:"Ciclo de vida de componentes"}),"\n",(0,c.jsx)(n.li,{children:"Suscripciones y temporizadores en React"}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"useEffect"})," es un hook esencial en React que permite manejar efectos secundarios en componentes funcionales. Es importante comprender c\xf3mo funciona dentro del ciclo de vida de un componente para usarlo correctamente, incluyendo cu\xe1ndo y c\xf3mo limpiar los efectos para evitar problemas de rendimiento y fugas de memoria. A trav\xe9s de su uso, podemos controlar de manera efectiva la l\xf3gica de nuestros componentes y asegurarnos de que respondan adecuadamente a los cambios en el estado y las props."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>d});var c=o(6540);const s={},a=c.createContext(s);function i(e){const n=c.useContext(a);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),c.createElement(a.Provider,{value:n},e.children)}}}]);