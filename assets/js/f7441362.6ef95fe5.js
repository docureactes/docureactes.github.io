"use strict";(self.webpackChunkdocubook=self.webpackChunkdocubook||[]).push([[6210],{6203:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var s=a(4848),o=a(8453);const c={},t="Diferencias entre useLayoutEffect y useEffect",i={id:"Hook/7-7-Diferencias entre useLayoutEffect y useEffect",title:"Diferencias entre useLayoutEffect y useEffect",description:"Cuando comenzamos a trabajar con React, uno de los aspectos m\xe1s importantes que debemos entender es c\xf3mo gestionar los efectos secundarios en nuestros componentes. Para esto, React nos proporciona dos hooks clave: useEffect y useLayoutEffect. Aunque a primera vista pueden parecer similares, tienen diferencias cruciales que afectan el rendimiento y el comportamiento de nuestros componentes. En esta secci\xf3n, te explicar\xe9 detalladamente estas diferencias y cu\xe1ndo utilizar cada uno.",source:"@site/docs/7-Hook/7-7-Diferencias entre useLayoutEffect y useEffect.md",sourceDirName:"7-Hook",slug:"/Hook/7-7-Diferencias entre useLayoutEffect y useEffect",permalink:"/Hook/7-7-Diferencias entre useLayoutEffect y useEffect",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"useLayoutEffect",permalink:"/Hook/7-6-useLayoutEffect"},next:{title:"useImperativeHandle",permalink:"/Hook/7-8-useImperativeHandle"}},r={},d=[{value:"\xbfQu\xe9 es <code>useEffect</code>?",id:"qu\xe9-es-useeffect",level:2},{value:"Ejemplo b\xe1sico de <code>useEffect</code>",id:"ejemplo-b\xe1sico-de-useeffect",level:3},{value:"\xbfQu\xe9 es <code>useLayoutEffect</code>?",id:"qu\xe9-es-uselayouteffect",level:2},{value:"Ejemplo b\xe1sico de <code>useLayoutEffect</code>",id:"ejemplo-b\xe1sico-de-uselayouteffect",level:3},{value:"Principales diferencias",id:"principales-diferencias",level:2},{value:"M\xe1s informaci\xf3n",id:"m\xe1s-informaci\xf3n",level:2},{value:"Resumen",id:"resumen",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"diferencias-entre-uselayouteffect-y-useeffect",children:"Diferencias entre useLayoutEffect y useEffect"}),"\n",(0,s.jsxs)(n.p,{children:["Cuando comenzamos a trabajar con React, uno de los aspectos m\xe1s importantes que debemos entender es c\xf3mo gestionar los efectos secundarios en nuestros componentes. Para esto, React nos proporciona dos hooks clave: ",(0,s.jsx)(n.code,{children:"useEffect"})," y ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),". Aunque a primera vista pueden parecer similares, tienen diferencias cruciales que afectan el rendimiento y el comportamiento de nuestros componentes. En esta secci\xf3n, te explicar\xe9 detalladamente estas diferencias y cu\xe1ndo utilizar cada uno."]}),"\n",(0,s.jsxs)(n.h2,{id:"qu\xe9-es-useeffect",children:["\xbfQu\xe9 es ",(0,s.jsx)(n.code,{children:"useEffect"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useEffect"})," es un hook que nos permite realizar efectos secundarios en componentes funcionales. Un efecto secundario es cualquier operaci\xf3n que afecta algo fuera del alcance de la funci\xf3n, como una llamada a una API, la manipulaci\xf3n del DOM, o suscripciones a eventos."]}),"\n",(0,s.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-useeffect",children:["Ejemplo b\xe1sico de ",(0,s.jsx)(n.code,{children:"useEffect"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useEffect, useState } from 'react';\n\nfunction EjemploUseEffect() {\n  const [contador, setContador] = useState(0);\n\n  // Este efecto se ejecuta despu\xe9s de cada renderizado\n  useEffect(() => {\n    document.title = `Has hecho clic ${contador} veces`;\n    // Este comentario indica que estamos actualizando el t\xedtulo del documento\n  });\n\n  return (\n    <div>\n      <p>Has hecho clic {contador} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Haz clic aqu\xed\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["En este ejemplo, el ",(0,s.jsx)(n.code,{children:"useEffect"})," se ejecuta despu\xe9s de que React haya actualizado el DOM. Es ideal para la mayor\xeda de los casos en los que necesitamos interactuar con el DOM o realizar operaciones as\xedncronas, como la obtenci\xf3n de datos de un servidor."]}),"\n",(0,s.jsxs)(n.h2,{id:"qu\xe9-es-uselayouteffect",children:["\xbfQu\xe9 es ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"useLayoutEffect"}),', por otro lado, se ejecuta justo despu\xe9s de que todas las mutaciones del DOM se hayan realizado, pero antes de que el navegador haya tenido la oportunidad de "pintar" la pantalla. Esto significa que ',(0,s.jsx)(n.code,{children:"useLayoutEffect"})," se ejecuta de manera s\xedncrona, bloqueando el pintado de la pantalla hasta que el efecto se haya completado."]}),"\n",(0,s.jsxs)(n.h3,{id:"ejemplo-b\xe1sico-de-uselayouteffect",children:["Ejemplo b\xe1sico de ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useLayoutEffect, useState } from 'react';\n\nfunction EjemploUseLayoutEffect() {\n  const [contador, setContador] = useState(0);\n\n  // Este efecto se ejecuta despu\xe9s de que el DOM haya sido mutado, pero antes del pintado\n  useLayoutEffect(() => {\n    if (contador === 0) {\n      const elemento = document.getElementById('mensaje');\n      elemento.style.color = 'red';\n      elemento.textContent = '\xa1Contador inicializado!';\n      // Aqu\xed estamos manipulando el DOM de forma directa y necesitamos que ocurra antes del pintado\n    }\n  }, [contador]);\n\n  return (\n    <div>\n      <p id=\"mensaje\">Has hecho clic {contador} veces</p>\n      <button onClick={() => setContador(contador + 1)}>\n        Haz clic aqu\xed\n      </button>\n    </div>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Este ejemplo muestra c\xf3mo ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," se asegura de que cualquier cambio en el DOM se aplique antes de que el navegador renderice la pantalla. Esto puede ser crucial para casos donde la interfaz debe estar completamente actualizada y consistente antes de mostrarse al usuario."]}),"\n",(0,s.jsx)(n.h2,{id:"principales-diferencias",children:"Principales diferencias"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Momento de ejecuci\xf3n"}),": ",(0,s.jsx)(n.code,{children:"useEffect"})," se ejecuta despu\xe9s de que el DOM se haya actualizado y el navegador haya pintado la pantalla. ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),", por el contrario, se ejecuta antes de que el navegador pinte la pantalla, justo despu\xe9s de que el DOM haya sido mutado."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Impacto en el rendimiento"}),": ",(0,s.jsx)(n.code,{children:"useEffect"})," no bloquea el pintado de la pantalla, lo que significa que no afecta la velocidad con la que se muestra el contenido al usuario. ",(0,s.jsx)(n.code,{children:"useLayoutEffect"}),", al ejecutarse de manera s\xedncrona, puede bloquear el pintado y, por lo tanto, afectar el rendimiento si se usa inadecuadamente."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Usos recomendados"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useEffect"})," se recomienda para la mayor\xeda de las operaciones as\xedncronas, como llamadas a APIs o actualizaciones que no necesitan ser inmediatas."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"useLayoutEffect"})," es mejor para operaciones que necesitan ocurrir antes de que el usuario vea la interfaz, como ajustes en el layout o mediciones precisas del DOM."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"m\xe1s-informaci\xf3n",children:"M\xe1s informaci\xf3n"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Efectos secundarios en React"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Pintado del navegador"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Rendimiento en aplicaciones React"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"DOM y manipulaci\xf3n del DOM"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"resumen",children:"Resumen"}),"\n",(0,s.jsxs)(n.p,{children:["En resumen, ",(0,s.jsx)(n.code,{children:"useEffect"})," y ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," son hooks que gestionan efectos secundarios, pero se ejecutan en momentos diferentes del ciclo de vida del componente. ",(0,s.jsx)(n.code,{children:"useEffect"})," es ideal para la mayor\xeda de las tareas as\xedncronas y no bloquea el renderizado, mientras que ",(0,s.jsx)(n.code,{children:"useLayoutEffect"})," es crucial cuando necesitas asegurar que las modificaciones en el DOM se realicen antes de que el navegador muestre la pantalla al usuario. Es importante elegir el hook correcto para evitar problemas de rendimiento y asegurar que la interfaz se comporte como se espera."]})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>t,x:()=>i});var s=a(6540);const o={},c=s.createContext(o);function t(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);